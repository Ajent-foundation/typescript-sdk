/* tslint:disable */
/* eslint-disable */
/**
 * tasknet-api
 * This Browser API (v1) provides a comprehensive suite of endpoints for managing automated browser sessions and browser fingerprinting, enabling users to create and control browser instances with customizable configurations. The API supports sophisticated fingerprinting capabilities for specifying browser characteristics (including screen properties, device capabilities, and proxy settings), session management features for controlling browser instances (with VNC connectivity options and lease time management), extension management for enhancing browser functionality, and page control operations for automated browsing.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: ajoor@tasker.ai
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface BaseError
 */
export interface BaseError {
    /**
     * 
     * @type {string}
     * @memberof BaseError
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof BaseError
     */
    'code': string;
    /**
     * 
     * @type {any}
     * @memberof BaseError
     */
    'details'?: any;
}
/**
 * Type of browser used for fingerprinting
 * @export
 * @enum {string}
 */

export const BrowserType = {
    Chromium: 'chromium'
} as const;

export type BrowserType = typeof BrowserType[keyof typeof BrowserType];


/**
 * 
 * @export
 * @interface ClickCommand
 */
export interface ClickCommand {
    /**
     * 
     * @type {string}
     * @memberof ClickCommand
     */
    'action': ClickCommandActionEnum;
    /**
     * 
     * @type {number}
     * @memberof ClickCommand
     */
    'x': number;
    /**
     * 
     * @type {number}
     * @memberof ClickCommand
     */
    'y': number;
    /**
     * 
     * @type {number}
     * @memberof ClickCommand
     */
    'clickCount'?: number;
    /**
     * 
     * @type {string}
     * @memberof ClickCommand
     */
    'button'?: ClickCommandButtonEnum;
}

export const ClickCommandActionEnum = {
    Click: 'Click'
} as const;

export type ClickCommandActionEnum = typeof ClickCommandActionEnum[keyof typeof ClickCommandActionEnum];
export const ClickCommandButtonEnum = {
    Left: 'left',
    Right: 'right',
    Middle: 'middle'
} as const;

export type ClickCommandButtonEnum = typeof ClickCommandButtonEnum[keyof typeof ClickCommandButtonEnum];

/**
 * 
 * @export
 * @interface ClosePageRequestBody
 */
export interface ClosePageRequestBody {
    /**
     * UUID of the browser session
     * @type {string}
     * @memberof ClosePageRequestBody
     */
    'sessionUUID': string;
    /**
     * Index of the page to close
     * @type {number}
     * @memberof ClosePageRequestBody
     */
    'index': number;
}
/**
 * 
 * @export
 * @interface CreateFingerprintRequestBody
 */
export interface CreateFingerprintRequestBody {
    /**
     * 
     * @type {string}
     * @memberof CreateFingerprintRequestBody
     */
    'environmentUUID': string;
    /**
     * 
     * @type {CreateFingerprintRequestBodyScreen}
     * @memberof CreateFingerprintRequestBody
     */
    'screen': CreateFingerprintRequestBodyScreen;
    /**
     * 
     * @type {CreateFingerprintRequestBodyDevice}
     * @memberof CreateFingerprintRequestBody
     */
    'device'?: CreateFingerprintRequestBodyDevice;
    /**
     * 
     * @type {CreateFingerprintRequestBodyProxy}
     * @memberof CreateFingerprintRequestBody
     */
    'proxy'?: CreateFingerprintRequestBodyProxy;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateFingerprintRequestBody
     */
    'extensions'?: Array<string>;
}
/**
 * 
 * @export
 * @interface CreateFingerprintRequestBodyDevice
 */
export interface CreateFingerprintRequestBodyDevice {
    /**
     * 
     * @type {number}
     * @memberof CreateFingerprintRequestBodyDevice
     */
    'numSpeakers'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateFingerprintRequestBodyDevice
     */
    'numMicrophones'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateFingerprintRequestBodyDevice
     */
    'numCameras'?: number;
}
/**
 * 
 * @export
 * @interface CreateFingerprintRequestBodyProxy
 */
export interface CreateFingerprintRequestBodyProxy {
    /**
     * 
     * @type {string}
     * @memberof CreateFingerprintRequestBodyProxy
     */
    'country'?: string;
}
/**
 * 
 * @export
 * @interface CreateFingerprintRequestBodyScreen
 */
export interface CreateFingerprintRequestBodyScreen {
    /**
     * 
     * @type {ScreenResolution}
     * @memberof CreateFingerprintRequestBodyScreen
     */
    'resolution': ScreenResolution;
    /**
     * 
     * @type {ScreenDepth}
     * @memberof CreateFingerprintRequestBodyScreen
     */
    'depth': ScreenDepth;
    /**
     * 
     * @type {ScreenDPI}
     * @memberof CreateFingerprintRequestBodyScreen
     */
    'dpi': ScreenDPI;
}


/**
 * 
 * @export
 * @interface CreateRandomFingerprintRequest
 */
export interface CreateRandomFingerprintRequest {
    /**
     * UUID of the environment to create the fingerprint in
     * @type {string}
     * @memberof CreateRandomFingerprintRequest
     */
    'environmentUUID': string;
}
/**
 * 
 * @export
 * @interface CreateSessionRequestBody
 */
export interface CreateSessionRequestBody {
    /**
     * 
     * @type {string}
     * @memberof CreateSessionRequestBody
     */
    'fingerprintUUID'?: string;
    /**
     * Duration of the session lease in minutes
     * @type {number}
     * @memberof CreateSessionRequestBody
     */
    'leaseTime': number;
    /**
     * Whether VNC access is enabled for this session
     * @type {boolean}
     * @memberof CreateSessionRequestBody
     */
    'isVncEnabled': boolean;
    /**
     * 
     * @type {VncMode}
     * @memberof CreateSessionRequestBody
     */
    'vncMode': VncMode;
    /**
     * 
     * @type {DriverType}
     * @memberof CreateSessionRequestBody
     */
    'driver': DriverType;
    /**
     * Whether to show mouse movements
     * @type {boolean}
     * @memberof CreateSessionRequestBody
     */
    'showMouse'?: boolean;
    /**
     * Whether to enable proxy for this session
     * @type {boolean}
     * @memberof CreateSessionRequestBody
     */
    'isProxyEnabled'?: boolean;
}


/**
 * 
 * @export
 * @interface DelayCommand
 */
export interface DelayCommand {
    /**
     * 
     * @type {string}
     * @memberof DelayCommand
     */
    'action': DelayCommandActionEnum;
    /**
     * Delay in milliseconds
     * @type {number}
     * @memberof DelayCommand
     */
    'delay': number;
}

export const DelayCommandActionEnum = {
    Delay: 'Delay'
} as const;

export type DelayCommandActionEnum = typeof DelayCommandActionEnum[keyof typeof DelayCommandActionEnum];

/**
 * Type of device being emulated
 * @export
 * @enum {string}
 */

export const DeviceType = {
    Desktop: 'desktop',
    Mobile: 'mobile',
    Tablet: 'tablet'
} as const;

export type DeviceType = typeof DeviceType[keyof typeof DeviceType];


/**
 * 
 * @export
 * @interface DownloadFileRequestBody
 */
export interface DownloadFileRequestBody {
    /**
     * Name of the file to download
     * @type {string}
     * @memberof DownloadFileRequestBody
     */
    'fileNames': string;
}
/**
 * Browser automation driver type
 * @export
 * @enum {string}
 */

export const DriverType = {
    Puppeteer: 'puppeteer',
    Api: 'api'
} as const;

export type DriverType = typeof DriverType[keyof typeof DriverType];


/**
 * 
 * @export
 * @interface Environment
 */
export interface Environment {
    /**
     * 
     * @type {string}
     * @memberof Environment
     */
    'environmentUUID': string;
    /**
     * 
     * @type {string}
     * @memberof Environment
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Environment
     */
    'publicKey': string;
    /**
     * 
     * @type {string}
     * @memberof Environment
     */
    'createdAt': string;
}
/**
 * 
 * @export
 * @interface EnvironmentWithSecret
 */
export interface EnvironmentWithSecret {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentWithSecret
     */
    'environmentUUID': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentWithSecret
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentWithSecret
     */
    'publicKey': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentWithSecret
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof EnvironmentWithSecret
     */
    'envSecret': string;
}
/**
 * 
 * @export
 * @interface Extension
 */
export interface Extension {
    /**
     * Brief description of the extension\'s functionality
     * @type {string}
     * @memberof Extension
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof Extension
     */
    'extensionUUID': string;
    /**
     * 
     * @type {string}
     * @memberof Extension
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Extension
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface ExtractRequestBody
 */
export interface ExtractRequestBody {
    /**
     * UUID of the browser session
     * @type {string}
     * @memberof ExtractRequestBody
     */
    'sessionUUID': string;
    /**
     * Query describing what data to extract
     * @type {string}
     * @memberof ExtractRequestBody
     */
    'userQuery': string;
    /**
     * Description of expected response format
     * @type {{ [key: string]: any; }}
     * @memberof ExtractRequestBody
     */
    'responseDescription': { [key: string]: any; };
    /**
     * Response format excluding links and images
     * @type {{ [key: string]: any; }}
     * @memberof ExtractRequestBody
     */
    'responseDescriptionNoLinkOrImage': { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface FileDownloadResponse
 */
export interface FileDownloadResponse {
    /**
     * Base64 encoded file content
     * @type {string}
     * @memberof FileDownloadResponse
     */
    'fileContent': string;
}
/**
 * 
 * @export
 * @interface FileUploadResponse
 */
export interface FileUploadResponse {
    /**
     * Name of the uploaded file
     * @type {string}
     * @memberof FileUploadResponse
     */
    'fileName': string;
}
/**
 * 
 * @export
 * @interface FilesListResponse
 */
export interface FilesListResponse {
    /**
     * List of file names
     * @type {Array<string>}
     * @memberof FilesListResponse
     */
    'files': Array<string>;
}
/**
 * 
 * @export
 * @interface Fingerprint
 */
export interface Fingerprint {
    /**
     * 
     * @type {string}
     * @memberof Fingerprint
     */
    'fingerprintUUID': string;
    /**
     * 
     * @type {boolean}
     * @memberof Fingerprint
     */
    'isArchived': boolean;
    /**
     * 
     * @type {FingerprintBrowserConfig}
     * @memberof Fingerprint
     */
    'browserConfig': FingerprintBrowserConfig;
    /**
     * 
     * @type {FingerprintProxy}
     * @memberof Fingerprint
     */
    'proxy': FingerprintProxy;
    /**
     * 
     * @type {string}
     * @memberof Fingerprint
     */
    'language': string;
    /**
     * 
     * @type {string}
     * @memberof Fingerprint
     */
    'timeZone': string;
    /**
     * 
     * @type {Platform}
     * @memberof Fingerprint
     */
    'platform': Platform;
    /**
     * 
     * @type {DeviceType}
     * @memberof Fingerprint
     */
    'deviceType': DeviceType;
    /**
     * 
     * @type {string}
     * @memberof Fingerprint
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Fingerprint
     */
    'updatedAt': string;
}


/**
 * 
 * @export
 * @interface FingerprintBrowserConfig
 */
export interface FingerprintBrowserConfig {
    /**
     * 
     * @type {BrowserType}
     * @memberof FingerprintBrowserConfig
     */
    'browser': BrowserType;
    /**
     * 
     * @type {Array<string>}
     * @memberof FingerprintBrowserConfig
     */
    'extensions': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof FingerprintBrowserConfig
     */
    'numCameras': number;
    /**
     * 
     * @type {number}
     * @memberof FingerprintBrowserConfig
     */
    'numMicrophones': number;
    /**
     * 
     * @type {number}
     * @memberof FingerprintBrowserConfig
     */
    'numSpeakers': number;
    /**
     * 
     * @type {ScreenDPI}
     * @memberof FingerprintBrowserConfig
     */
    'screenDPI': ScreenDPI;
    /**
     * 
     * @type {ScreenDepth}
     * @memberof FingerprintBrowserConfig
     */
    'screenDepth': ScreenDepth;
    /**
     * 
     * @type {ScreenResolution}
     * @memberof FingerprintBrowserConfig
     */
    'screenResolution': ScreenResolution;
}


/**
 * 
 * @export
 * @interface FingerprintProxy
 */
export interface FingerprintProxy {
    /**
     * 
     * @type {Array<string>}
     * @memberof FingerprintProxy
     */
    'appliedDomains': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof FingerprintProxy
     */
    'city': string;
    /**
     * 
     * @type {string}
     * @memberof FingerprintProxy
     */
    'country': string;
    /**
     * 
     * @type {string}
     * @memberof FingerprintProxy
     */
    'state': string;
    /**
     * 
     * @type {ProxyType}
     * @memberof FingerprintProxy
     */
    'type': ProxyType;
}


/**
 * 
 * @export
 * @interface FingerprintWithSecret
 */
export interface FingerprintWithSecret {
    /**
     * 
     * @type {string}
     * @memberof FingerprintWithSecret
     */
    'fingerprintUUID': string;
    /**
     * 
     * @type {boolean}
     * @memberof FingerprintWithSecret
     */
    'isArchived': boolean;
    /**
     * 
     * @type {FingerprintBrowserConfig}
     * @memberof FingerprintWithSecret
     */
    'browserConfig': FingerprintBrowserConfig;
    /**
     * 
     * @type {FingerprintProxy}
     * @memberof FingerprintWithSecret
     */
    'proxy': FingerprintProxy;
    /**
     * 
     * @type {string}
     * @memberof FingerprintWithSecret
     */
    'language': string;
    /**
     * 
     * @type {string}
     * @memberof FingerprintWithSecret
     */
    'timeZone': string;
    /**
     * 
     * @type {Platform}
     * @memberof FingerprintWithSecret
     */
    'platform': Platform;
    /**
     * 
     * @type {DeviceType}
     * @memberof FingerprintWithSecret
     */
    'deviceType': DeviceType;
    /**
     * 
     * @type {string}
     * @memberof FingerprintWithSecret
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof FingerprintWithSecret
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof FingerprintWithSecret
     */
    'fingerprintSecret'?: string;
}


/**
 * 
 * @export
 * @interface FullScreenshotCommand
 */
export interface FullScreenshotCommand {
    /**
     * 
     * @type {string}
     * @memberof FullScreenshotCommand
     */
    'action': FullScreenshotCommandActionEnum;
}

export const FullScreenshotCommandActionEnum = {
    FullScreenshot: 'FullScreenshot'
} as const;

export type FullScreenshotCommandActionEnum = typeof FullScreenshotCommandActionEnum[keyof typeof FullScreenshotCommandActionEnum];

/**
 * 
 * @export
 * @interface GetElmsCommand
 */
export interface GetElmsCommand {
    /**
     * 
     * @type {string}
     * @memberof GetElmsCommand
     */
    'action': GetElmsCommandActionEnum;
    /**
     * CSS selector to find elements
     * @type {string}
     * @memberof GetElmsCommand
     */
    'selector': string;
}

export const GetElmsCommandActionEnum = {
    GetElms: 'GetElms'
} as const;

export type GetElmsCommandActionEnum = typeof GetElmsCommandActionEnum[keyof typeof GetElmsCommandActionEnum];

/**
 * 
 * @export
 * @interface GetRepeatedElmsByXpathCommand
 */
export interface GetRepeatedElmsByXpathCommand {
    /**
     * 
     * @type {string}
     * @memberof GetRepeatedElmsByXpathCommand
     */
    'action': GetRepeatedElmsByXpathCommandActionEnum;
    /**
     * XPath selector to find repeated elements
     * @type {string}
     * @memberof GetRepeatedElmsByXpathCommand
     */
    'xpath': string;
}

export const GetRepeatedElmsByXpathCommandActionEnum = {
    GetRepeatedElmsByXpath: 'GetRepeatedElmsByXpath'
} as const;

export type GetRepeatedElmsByXpathCommandActionEnum = typeof GetRepeatedElmsByXpathCommandActionEnum[keyof typeof GetRepeatedElmsByXpathCommandActionEnum];

/**
 * 
 * @export
 * @interface GetRepeatedElmsCommand
 */
export interface GetRepeatedElmsCommand {
    /**
     * 
     * @type {string}
     * @memberof GetRepeatedElmsCommand
     */
    'action': GetRepeatedElmsCommandActionEnum;
    /**
     * CSS selector to find repeated elements
     * @type {string}
     * @memberof GetRepeatedElmsCommand
     */
    'selector': string;
}

export const GetRepeatedElmsCommandActionEnum = {
    GetRepeatedElms: 'GetRepeatedElms'
} as const;

export type GetRepeatedElmsCommandActionEnum = typeof GetRepeatedElmsCommandActionEnum[keyof typeof GetRepeatedElmsCommandActionEnum];

/**
 * 
 * @export
 * @interface GoBackRequestBody
 */
export interface GoBackRequestBody {
    /**
     * UUID of the browser session
     * @type {string}
     * @memberof GoBackRequestBody
     */
    'sessionUUID': string;
    /**
     * Whether to stay on the current page after going back
     * @type {boolean}
     * @memberof GoBackRequestBody
     */
    'stayOnPage'?: boolean;
}
/**
 * 
 * @export
 * @interface HoverCommand
 */
export interface HoverCommand {
    /**
     * 
     * @type {string}
     * @memberof HoverCommand
     */
    'action': HoverCommandActionEnum;
    /**
     * 
     * @type {number}
     * @memberof HoverCommand
     */
    'x': number;
    /**
     * 
     * @type {number}
     * @memberof HoverCommand
     */
    'y': number;
}

export const HoverCommandActionEnum = {
    Hover: 'Hover'
} as const;

export type HoverCommandActionEnum = typeof HoverCommandActionEnum[keyof typeof HoverCommandActionEnum];

/**
 * 
 * @export
 * @interface KeyPressCommand
 */
export interface KeyPressCommand {
    /**
     * 
     * @type {string}
     * @memberof KeyPressCommand
     */
    'action': KeyPressCommandActionEnum;
    /**
     * Key to press (e.g., \"Enter\", \"Tab\", \"a\", etc.)
     * @type {string}
     * @memberof KeyPressCommand
     */
    'key': string;
}

export const KeyPressCommandActionEnum = {
    KeyPress: 'KeyPress'
} as const;

export type KeyPressCommandActionEnum = typeof KeyPressCommandActionEnum[keyof typeof KeyPressCommandActionEnum];

/**
 * 
 * @export
 * @interface MarkdownRequestBody
 */
export interface MarkdownRequestBody {
    /**
     * UUID of the browser session
     * @type {string}
     * @memberof MarkdownRequestBody
     */
    'sessionUUID': string;
}
/**
 * 
 * @export
 * @interface MarkdownResponse
 */
export interface MarkdownResponse {
    /**
     * Page content in markdown format
     * @type {string}
     * @memberof MarkdownResponse
     */
    'page': string;
}
/**
 * 
 * @export
 * @interface ModeV1EnvironmentsGet200Response
 */
export interface ModeV1EnvironmentsGet200Response {
    /**
     * 
     * @type {Array<Environment>}
     * @memberof ModeV1EnvironmentsGet200Response
     */
    'environments'?: Array<Environment>;
}
/**
 * 
 * @export
 * @interface ModeV1EnvironmentsPostRequest
 */
export interface ModeV1EnvironmentsPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ModeV1EnvironmentsPostRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ModeV1ExtensionsGet200Response
 */
export interface ModeV1ExtensionsGet200Response {
    /**
     * 
     * @type {Array<Extension>}
     * @memberof ModeV1ExtensionsGet200Response
     */
    'extensions'?: Array<Extension>;
}
/**
 * 
 * @export
 * @interface ModeV1FingerprintsGet200Response
 */
export interface ModeV1FingerprintsGet200Response {
    /**
     * 
     * @type {Array<Fingerprint>}
     * @memberof ModeV1FingerprintsGet200Response
     */
    'fingerprints'?: Array<Fingerprint>;
    /**
     * 
     * @type {number}
     * @memberof ModeV1FingerprintsGet200Response
     */
    'prevPage'?: number;
    /**
     * 
     * @type {number}
     * @memberof ModeV1FingerprintsGet200Response
     */
    'nextPage'?: number;
    /**
     * 
     * @type {number}
     * @memberof ModeV1FingerprintsGet200Response
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface ModeV1PageExecuteCommandsPostRequest
 */
export interface ModeV1PageExecuteCommandsPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ModeV1PageExecuteCommandsPostRequest
     */
    'sessionUUID': string;
    /**
     * 
     * @type {Array<ModeV1PageExecuteCommandsPostRequestCommandsInner>}
     * @memberof ModeV1PageExecuteCommandsPostRequest
     */
    'commands': Array<ModeV1PageExecuteCommandsPostRequestCommandsInner>;
}
/**
 * @type ModeV1PageExecuteCommandsPostRequestCommandsInner
 * @export
 */
export type ModeV1PageExecuteCommandsPostRequestCommandsInner = ClickCommand | DelayCommand | FullScreenshotCommand | GetElmsCommand | GetRepeatedElmsByXpathCommand | GetRepeatedElmsCommand | HoverCommand | KeyPressCommand | ScreenShotCommand | ScrollAtPositionCommand | ScrollBottomCommand | ScrollNextCommand | ScrollToCommand | ScrollTopCommand | SelectCommand | TypeInputCommand | UnknownCommand;

/**
 * 
 * @export
 * @interface ModeV1PageGoToPagePostRequest
 */
export interface ModeV1PageGoToPagePostRequest {
    /**
     * 
     * @type {string}
     * @memberof ModeV1PageGoToPagePostRequest
     */
    'sessionUUID': string;
    /**
     * 
     * @type {string}
     * @memberof ModeV1PageGoToPagePostRequest
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface ModeV1SessionsGet200Response
 */
export interface ModeV1SessionsGet200Response {
    /**
     * 
     * @type {Array<Session>}
     * @memberof ModeV1SessionsGet200Response
     */
    'sessions'?: Array<Session>;
}
/**
 * 
 * @export
 * @interface NewPageRequestBody
 */
export interface NewPageRequestBody {
    /**
     * UUID of the browser session
     * @type {string}
     * @memberof NewPageRequestBody
     */
    'sessionUUID': string;
}
/**
 * 
 * @export
 * @interface NotFoundError
 */
export interface NotFoundError {
    /**
     * 
     * @type {string}
     * @memberof NotFoundError
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof NotFoundError
     */
    'code': string;
    /**
     * 
     * @type {NotFoundErrorAllOfDetails}
     * @memberof NotFoundError
     */
    'details'?: NotFoundErrorAllOfDetails;
}
/**
 * 
 * @export
 * @interface NotFoundErrorAllOfDetails
 */
export interface NotFoundErrorAllOfDetails {
    /**
     * 
     * @type {string}
     * @memberof NotFoundErrorAllOfDetails
     */
    'resource'?: string;
    /**
     * 
     * @type {string}
     * @memberof NotFoundErrorAllOfDetails
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface Operator
 */
export interface Operator {
    /**
     * 
     * @type {number}
     * @memberof Operator
     */
    'numOfBrowsers': number;
    /**
     * 
     * @type {OperatorInfo}
     * @memberof Operator
     */
    'info': OperatorInfo;
    /**
     * 
     * @type {string}
     * @memberof Operator
     */
    'connectedAt': string;
    /**
     * 
     * @type {string}
     * @memberof Operator
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface OperatorInfo
 */
export interface OperatorInfo {
    /**
     * 
     * @type {string}
     * @memberof OperatorInfo
     */
    'platform': string;
    /**
     * 
     * @type {string}
     * @memberof OperatorInfo
     */
    'architecture': string;
    /**
     * 
     * @type {number}
     * @memberof OperatorInfo
     */
    'freeMemory': number;
    /**
     * 
     * @type {number}
     * @memberof OperatorInfo
     */
    'totalMemory': number;
    /**
     * 
     * @type {string}
     * @memberof OperatorInfo
     */
    'cpuModel': string;
    /**
     * 
     * @type {string}
     * @memberof OperatorInfo
     */
    'hostname': string;
}
/**
 * 
 * @export
 * @interface PageInfoResponse
 */
export interface PageInfoResponse {
    /**
     * ID of the browser session
     * @type {string}
     * @memberof PageInfoResponse
     */
    'sessionID': string;
    /**
     * 
     * @type {PageInfoResponsePage}
     * @memberof PageInfoResponse
     */
    'page': PageInfoResponsePage;
}
/**
 * 
 * @export
 * @interface PageInfoResponsePage
 */
export interface PageInfoResponsePage {
    /**
     * Current page URL
     * @type {string}
     * @memberof PageInfoResponsePage
     */
    'url': string;
    /**
     * Device pixel ratio
     * @type {number}
     * @memberof PageInfoResponsePage
     */
    'devicePixelRatio': number;
    /**
     * Scroll information
     * @type {object}
     * @memberof PageInfoResponsePage
     */
    'scroller': object;
    /**
     * 
     * @type {PageInfoResponsePagePageDimensions}
     * @memberof PageInfoResponsePage
     */
    'pageDimensions': PageInfoResponsePagePageDimensions;
    /**
     * Base64 encoded page screenshot
     * @type {string}
     * @memberof PageInfoResponsePage
     */
    'img': string;
}
/**
 * 
 * @export
 * @interface PageInfoResponsePagePageDimensions
 */
export interface PageInfoResponsePagePageDimensions {
    /**
     * Page width
     * @type {number}
     * @memberof PageInfoResponsePagePageDimensions
     */
    'width': number;
    /**
     * Page height (scroll height)
     * @type {number}
     * @memberof PageInfoResponsePagePageDimensions
     */
    'height': number;
}
/**
 * 
 * @export
 * @interface PdfRequestBody
 */
export interface PdfRequestBody {
    /**
     * UUID of the browser session
     * @type {string}
     * @memberof PdfRequestBody
     */
    'sessionUUID': string;
}
/**
 * 
 * @export
 * @interface PdfResponse
 */
export interface PdfResponse {
    /**
     * Base64 encoded PDF content
     * @type {string}
     * @memberof PdfResponse
     */
    'page': string;
}
/**
 * Operating system platform
 * @export
 * @enum {string}
 */

export const Platform = {
    Windows: 'Windows',
    MacOs: 'MacOS',
    Linux: 'Linux',
    Android: 'Android',
    IOs: 'iOS'
} as const;

export type Platform = typeof Platform[keyof typeof Platform];


/**
 * Type of proxy connection
 * @export
 * @enum {string}
 */

export const ProxyType = {
    Residential: 'residential'
} as const;

export type ProxyType = typeof ProxyType[keyof typeof ProxyType];


/**
 * 
 * @export
 * @interface RegisterApiKeyRequestBody
 */
export interface RegisterApiKeyRequestBody {
    /**
     * API key to register for VNC access
     * @type {string}
     * @memberof RegisterApiKeyRequestBody
     */
    'apiKey': string;
}
/**
 * Valid DPI (Dots Per Inch) values for screen configuration Possible values: 96, 120, 144, 192 
 * @export
 * @enum {number}
 */

export const ScreenDPI = {
    NUMBER_96: 96,
    NUMBER_120: 120,
    NUMBER_144: 144,
    NUMBER_192: 192
} as const;

export type ScreenDPI = typeof ScreenDPI[keyof typeof ScreenDPI];


/**
 * Valid color depth values for screen configuration Possible values: 24, 30, 32 
 * @export
 * @enum {number}
 */

export const ScreenDepth = {
    NUMBER_24: 24,
    NUMBER_30: 30,
    NUMBER_32: 32
} as const;

export type ScreenDepth = typeof ScreenDepth[keyof typeof ScreenDepth];


/**
 * Valid screen resolution values Common display resolutions in \"widthxheight\" format 
 * @export
 * @enum {string}
 */

export const ScreenResolution = {
    _1280x1024: '1280x1024',
    _1920x1080: '1920x1080',
    _1366x768: '1366x768',
    _1536x864: '1536x864',
    _1280x720: '1280x720',
    _1440x900: '1440x900',
    _1280x2400: '1280x2400'
} as const;

export type ScreenResolution = typeof ScreenResolution[keyof typeof ScreenResolution];


/**
 * 
 * @export
 * @interface ScreenShotCommand
 */
export interface ScreenShotCommand {
    /**
     * 
     * @type {string}
     * @memberof ScreenShotCommand
     */
    'action': ScreenShotCommandActionEnum;
    /**
     * 
     * @type {number}
     * @memberof ScreenShotCommand
     */
    'x': number;
    /**
     * 
     * @type {number}
     * @memberof ScreenShotCommand
     */
    'y': number;
    /**
     * 
     * @type {number}
     * @memberof ScreenShotCommand
     */
    'width': number;
    /**
     * 
     * @type {number}
     * @memberof ScreenShotCommand
     */
    'height': number;
}

export const ScreenShotCommandActionEnum = {
    ScreenShot: 'ScreenShot'
} as const;

export type ScreenShotCommandActionEnum = typeof ScreenShotCommandActionEnum[keyof typeof ScreenShotCommandActionEnum];

/**
 * 
 * @export
 * @interface ScrollAtPositionCommand
 */
export interface ScrollAtPositionCommand {
    /**
     * 
     * @type {string}
     * @memberof ScrollAtPositionCommand
     */
    'action': ScrollAtPositionCommandActionEnum;
    /**
     * 
     * @type {number}
     * @memberof ScrollAtPositionCommand
     */
    'x': number;
    /**
     * 
     * @type {number}
     * @memberof ScrollAtPositionCommand
     */
    'y': number;
    /**
     * 
     * @type {number}
     * @memberof ScrollAtPositionCommand
     */
    'factor': number;
    /**
     * 
     * @type {string}
     * @memberof ScrollAtPositionCommand
     */
    'axis': string;
}

export const ScrollAtPositionCommandActionEnum = {
    ScrollAtPosition: 'ScrollAtPosition'
} as const;

export type ScrollAtPositionCommandActionEnum = typeof ScrollAtPositionCommandActionEnum[keyof typeof ScrollAtPositionCommandActionEnum];

/**
 * 
 * @export
 * @interface ScrollBottomCommand
 */
export interface ScrollBottomCommand {
    /**
     * 
     * @type {string}
     * @memberof ScrollBottomCommand
     */
    'action': ScrollBottomCommandActionEnum;
}

export const ScrollBottomCommandActionEnum = {
    ScrollBottom: 'ScrollBottom'
} as const;

export type ScrollBottomCommandActionEnum = typeof ScrollBottomCommandActionEnum[keyof typeof ScrollBottomCommandActionEnum];

/**
 * 
 * @export
 * @interface ScrollNextCommand
 */
export interface ScrollNextCommand {
    /**
     * 
     * @type {string}
     * @memberof ScrollNextCommand
     */
    'action': ScrollNextCommandActionEnum;
}

export const ScrollNextCommandActionEnum = {
    ScrollNext: 'ScrollNext'
} as const;

export type ScrollNextCommandActionEnum = typeof ScrollNextCommandActionEnum[keyof typeof ScrollNextCommandActionEnum];

/**
 * 
 * @export
 * @interface ScrollToCommand
 */
export interface ScrollToCommand {
    /**
     * 
     * @type {string}
     * @memberof ScrollToCommand
     */
    'action': ScrollToCommandActionEnum;
    /**
     * 
     * @type {number}
     * @memberof ScrollToCommand
     */
    'x': number;
    /**
     * 
     * @type {number}
     * @memberof ScrollToCommand
     */
    'y': number;
}

export const ScrollToCommandActionEnum = {
    ScrollTo: 'ScrollTo'
} as const;

export type ScrollToCommandActionEnum = typeof ScrollToCommandActionEnum[keyof typeof ScrollToCommandActionEnum];

/**
 * 
 * @export
 * @interface ScrollTopCommand
 */
export interface ScrollTopCommand {
    /**
     * 
     * @type {string}
     * @memberof ScrollTopCommand
     */
    'action': ScrollTopCommandActionEnum;
}

export const ScrollTopCommandActionEnum = {
    ScrollTop: 'ScrollTop'
} as const;

export type ScrollTopCommandActionEnum = typeof ScrollTopCommandActionEnum[keyof typeof ScrollTopCommandActionEnum];

/**
 * 
 * @export
 * @interface SelectCommand
 */
export interface SelectCommand {
    /**
     * 
     * @type {string}
     * @memberof SelectCommand
     */
    'action': SelectCommandActionEnum;
    /**
     * 
     * @type {number}
     * @memberof SelectCommand
     */
    'x': number;
    /**
     * 
     * @type {number}
     * @memberof SelectCommand
     */
    'y': number;
    /**
     * 
     * @type {string}
     * @memberof SelectCommand
     */
    'value': string;
}

export const SelectCommandActionEnum = {
    Select: 'Select'
} as const;

export type SelectCommandActionEnum = typeof SelectCommandActionEnum[keyof typeof SelectCommandActionEnum];

/**
 * 
 * @export
 * @interface Session
 */
export interface Session {
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'sessionUUID': string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'fingerprintUUID': string;
    /**
     * 
     * @type {number}
     * @memberof Session
     */
    'currentLeaseTime': number;
    /**
     * 
     * @type {boolean}
     * @memberof Session
     */
    'isVncEnabled': boolean;
    /**
     * VNC password for accessing the session
     * @type {string}
     * @memberof Session
     */
    'vncPassword'?: string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'updatedAt': string;
    /**
     * 
     * @type {DriverType}
     * @memberof Session
     */
    'driver': DriverType;
    /**
     * 
     * @type {SessionStatus}
     * @memberof Session
     */
    'status': SessionStatus;
    /**
     * 
     * @type {VncMode}
     * @memberof Session
     */
    'vncMode': VncMode;
}


/**
 * The status of the session
 * @export
 * @enum {string}
 */

export const SessionStatus = {
    Running: 'running',
    Terminated: 'terminated'
} as const;

export type SessionStatus = typeof SessionStatus[keyof typeof SessionStatus];


/**
 * 
 * @export
 * @interface SwitchPageRequestBody
 */
export interface SwitchPageRequestBody {
    /**
     * UUID of the browser session
     * @type {string}
     * @memberof SwitchPageRequestBody
     */
    'sessionUUID': string;
    /**
     * Index of the page to switch to
     * @type {number}
     * @memberof SwitchPageRequestBody
     */
    'index': number;
}
/**
 * 
 * @export
 * @interface TypeInputCommand
 */
export interface TypeInputCommand {
    /**
     * 
     * @type {string}
     * @memberof TypeInputCommand
     */
    'action': TypeInputCommandActionEnum;
    /**
     * 
     * @type {number}
     * @memberof TypeInputCommand
     */
    'x': number;
    /**
     * 
     * @type {number}
     * @memberof TypeInputCommand
     */
    'y': number;
    /**
     * 
     * @type {string}
     * @memberof TypeInputCommand
     */
    'input': string;
}

export const TypeInputCommandActionEnum = {
    TypeInput: 'TypeInput'
} as const;

export type TypeInputCommandActionEnum = typeof TypeInputCommandActionEnum[keyof typeof TypeInputCommandActionEnum];

/**
 * Fallback command type for unknown or custom actions
 * @export
 * @interface UnknownCommand
 */
export interface UnknownCommand {
    [key: string]: any;

    /**
     * Any action type not covered by specific commands
     * @type {string}
     * @memberof UnknownCommand
     */
    'action': string;
}
/**
 * 
 * @export
 * @interface UpdateFingerprintProxyRequest
 */
export interface UpdateFingerprintProxyRequest {
    /**
     * Two-letter ISO country code for proxy location
     * @type {string}
     * @memberof UpdateFingerprintProxyRequest
     */
    'country': string;
}
/**
 * 
 * @export
 * @interface UpdateSessionRequestBody
 */
export interface UpdateSessionRequestBody {
    /**
     * 
     * @type {number}
     * @memberof UpdateSessionRequestBody
     */
    'newLeaseTime': number;
}
/**
 * 
 * @export
 * @interface UploadFileRequestBody
 */
export interface UploadFileRequestBody {
    /**
     * Base64 encoded file content to upload
     * @type {string}
     * @memberof UploadFileRequestBody
     */
    'base64File': string;
}
/**
 * 
 * @export
 * @interface V1OperatorsInfoGet200Response
 */
export interface V1OperatorsInfoGet200Response {
    /**
     * 
     * @type {Array<Operator>}
     * @memberof V1OperatorsInfoGet200Response
     */
    'nodes': Array<Operator>;
    /**
     * 
     * @type {number}
     * @memberof V1OperatorsInfoGet200Response
     */
    'browsers': number;
}
/**
 * 
 * @export
 * @interface V1OperatorsListAllGet200Response
 */
export interface V1OperatorsListAllGet200Response {
    /**
     * 
     * @type {Array<Operator>}
     * @memberof V1OperatorsListAllGet200Response
     */
    'nodes': Array<Operator>;
}
/**
 * 
 * @export
 * @interface V1OperatorsRandomGet200Response
 */
export interface V1OperatorsRandomGet200Response {
    /**
     * 
     * @type {string}
     * @memberof V1OperatorsRandomGet200Response
     */
    'operatorId': string;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'code': string;
    /**
     * 
     * @type {ValidationErrorAllOfDetails}
     * @memberof ValidationError
     */
    'details'?: ValidationErrorAllOfDetails;
}
/**
 * 
 * @export
 * @interface ValidationErrorAllOfDetails
 */
export interface ValidationErrorAllOfDetails {
    /**
     * 
     * @type {string}
     * @memberof ValidationErrorAllOfDetails
     */
    'field'?: string;
    /**
     * 
     * @type {string}
     * @memberof ValidationErrorAllOfDetails
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface VncClientControlRequestBody
 */
export interface VncClientControlRequestBody {
    /**
     * ID of the VNC client
     * @type {string}
     * @memberof VncClientControlRequestBody
     */
    'clientId': string;
}
/**
 * 
 * @export
 * @interface VncClientsResponse
 */
export interface VncClientsResponse {
    /**
     * List of connected VNC clients
     * @type {Array<object>}
     * @memberof VncClientsResponse
     */
    'clients': Array<object>;
}
/**
 * VNC access mode (read-write or read-only)
 * @export
 * @enum {string}
 */

export const VncMode = {
    Rw: 'rw',
    Ro: 'ro'
} as const;

export type VncMode = typeof VncMode[keyof typeof VncMode];



/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary isRunning?
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rootGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary isRunning?
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rootGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rootGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.rootGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary isRunning?
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rootGet(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rootGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary isRunning?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public rootGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).rootGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EnvironmentsApi - axios parameter creator
 * @export
 */
export const EnvironmentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a specific environment
         * @summary DeleteEnvironment
         * @param {string} mode 
         * @param {string} environmentUUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1EnvironmentsEnvironmentUUIDDelete: async (mode: string, environmentUUID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mode' is not null or undefined
            assertParamExists('modeV1EnvironmentsEnvironmentUUIDDelete', 'mode', mode)
            // verify required parameter 'environmentUUID' is not null or undefined
            assertParamExists('modeV1EnvironmentsEnvironmentUUIDDelete', 'environmentUUID', environmentUUID)
            const localVarPath = `/{mode}/v1/environments/{environmentUUID}`
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)))
                .replace(`{${"environmentUUID"}}`, encodeURIComponent(String(environmentUUID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves details of a specific environment
         * @summary GetEnvironment
         * @param {string} mode 
         * @param {string} environmentUUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1EnvironmentsEnvironmentUUIDGet: async (mode: string, environmentUUID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mode' is not null or undefined
            assertParamExists('modeV1EnvironmentsEnvironmentUUIDGet', 'mode', mode)
            // verify required parameter 'environmentUUID' is not null or undefined
            assertParamExists('modeV1EnvironmentsEnvironmentUUIDGet', 'environmentUUID', environmentUUID)
            const localVarPath = `/{mode}/v1/environments/{environmentUUID}`
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)))
                .replace(`{${"environmentUUID"}}`, encodeURIComponent(String(environmentUUID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of all environments
         * @summary ListEnvironments
         * @param {string} mode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1EnvironmentsGet: async (mode: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mode' is not null or undefined
            assertParamExists('modeV1EnvironmentsGet', 'mode', mode)
            const localVarPath = `/{mode}/v1/environments`
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new environment
         * @summary CreateEnvironment
         * @param {string} mode 
         * @param {ModeV1EnvironmentsPostRequest} modeV1EnvironmentsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1EnvironmentsPost: async (mode: string, modeV1EnvironmentsPostRequest: ModeV1EnvironmentsPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mode' is not null or undefined
            assertParamExists('modeV1EnvironmentsPost', 'mode', mode)
            // verify required parameter 'modeV1EnvironmentsPostRequest' is not null or undefined
            assertParamExists('modeV1EnvironmentsPost', 'modeV1EnvironmentsPostRequest', modeV1EnvironmentsPostRequest)
            const localVarPath = `/{mode}/v1/environments`
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(modeV1EnvironmentsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnvironmentsApi - functional programming interface
 * @export
 */
export const EnvironmentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnvironmentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes a specific environment
         * @summary DeleteEnvironment
         * @param {string} mode 
         * @param {string} environmentUUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modeV1EnvironmentsEnvironmentUUIDDelete(mode: string, environmentUUID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modeV1EnvironmentsEnvironmentUUIDDelete(mode, environmentUUID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentsApi.modeV1EnvironmentsEnvironmentUUIDDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves details of a specific environment
         * @summary GetEnvironment
         * @param {string} mode 
         * @param {string} environmentUUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modeV1EnvironmentsEnvironmentUUIDGet(mode: string, environmentUUID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Environment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modeV1EnvironmentsEnvironmentUUIDGet(mode, environmentUUID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentsApi.modeV1EnvironmentsEnvironmentUUIDGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of all environments
         * @summary ListEnvironments
         * @param {string} mode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modeV1EnvironmentsGet(mode: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModeV1EnvironmentsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modeV1EnvironmentsGet(mode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentsApi.modeV1EnvironmentsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new environment
         * @summary CreateEnvironment
         * @param {string} mode 
         * @param {ModeV1EnvironmentsPostRequest} modeV1EnvironmentsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modeV1EnvironmentsPost(mode: string, modeV1EnvironmentsPostRequest: ModeV1EnvironmentsPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentWithSecret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modeV1EnvironmentsPost(mode, modeV1EnvironmentsPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentsApi.modeV1EnvironmentsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EnvironmentsApi - factory interface
 * @export
 */
export const EnvironmentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnvironmentsApiFp(configuration)
    return {
        /**
         * Deletes a specific environment
         * @summary DeleteEnvironment
         * @param {string} mode 
         * @param {string} environmentUUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1EnvironmentsEnvironmentUUIDDelete(mode: string, environmentUUID: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.modeV1EnvironmentsEnvironmentUUIDDelete(mode, environmentUUID, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves details of a specific environment
         * @summary GetEnvironment
         * @param {string} mode 
         * @param {string} environmentUUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1EnvironmentsEnvironmentUUIDGet(mode: string, environmentUUID: string, options?: RawAxiosRequestConfig): AxiosPromise<Environment> {
            return localVarFp.modeV1EnvironmentsEnvironmentUUIDGet(mode, environmentUUID, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of all environments
         * @summary ListEnvironments
         * @param {string} mode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1EnvironmentsGet(mode: string, options?: RawAxiosRequestConfig): AxiosPromise<ModeV1EnvironmentsGet200Response> {
            return localVarFp.modeV1EnvironmentsGet(mode, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new environment
         * @summary CreateEnvironment
         * @param {string} mode 
         * @param {ModeV1EnvironmentsPostRequest} modeV1EnvironmentsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1EnvironmentsPost(mode: string, modeV1EnvironmentsPostRequest: ModeV1EnvironmentsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<EnvironmentWithSecret> {
            return localVarFp.modeV1EnvironmentsPost(mode, modeV1EnvironmentsPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EnvironmentsApi - object-oriented interface
 * @export
 * @class EnvironmentsApi
 * @extends {BaseAPI}
 */
export class EnvironmentsApi extends BaseAPI {
    /**
     * Deletes a specific environment
     * @summary DeleteEnvironment
     * @param {string} mode 
     * @param {string} environmentUUID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public modeV1EnvironmentsEnvironmentUUIDDelete(mode: string, environmentUUID: string, options?: RawAxiosRequestConfig) {
        return EnvironmentsApiFp(this.configuration).modeV1EnvironmentsEnvironmentUUIDDelete(mode, environmentUUID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves details of a specific environment
     * @summary GetEnvironment
     * @param {string} mode 
     * @param {string} environmentUUID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public modeV1EnvironmentsEnvironmentUUIDGet(mode: string, environmentUUID: string, options?: RawAxiosRequestConfig) {
        return EnvironmentsApiFp(this.configuration).modeV1EnvironmentsEnvironmentUUIDGet(mode, environmentUUID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of all environments
     * @summary ListEnvironments
     * @param {string} mode 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public modeV1EnvironmentsGet(mode: string, options?: RawAxiosRequestConfig) {
        return EnvironmentsApiFp(this.configuration).modeV1EnvironmentsGet(mode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new environment
     * @summary CreateEnvironment
     * @param {string} mode 
     * @param {ModeV1EnvironmentsPostRequest} modeV1EnvironmentsPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public modeV1EnvironmentsPost(mode: string, modeV1EnvironmentsPostRequest: ModeV1EnvironmentsPostRequest, options?: RawAxiosRequestConfig) {
        return EnvironmentsApiFp(this.configuration).modeV1EnvironmentsPost(mode, modeV1EnvironmentsPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ExtensionsApi - axios parameter creator
 * @export
 */
export const ExtensionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves detailed information about a specific browser extension, including its name, description, and installation URL.
         * @summary GetExtension
         * @param {string} mode 
         * @param {string} extensionUUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1ExtensionsExtensionUUIDGet: async (mode: string, extensionUUID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mode' is not null or undefined
            assertParamExists('modeV1ExtensionsExtensionUUIDGet', 'mode', mode)
            // verify required parameter 'extensionUUID' is not null or undefined
            assertParamExists('modeV1ExtensionsExtensionUUIDGet', 'extensionUUID', extensionUUID)
            const localVarPath = `/{mode}/v1/extensions/{extensionUUID}`
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)))
                .replace(`{${"extensionUUID"}}`, encodeURIComponent(String(extensionUUID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of all available browser extensions that can be added to fingerprints. These extensions can enhance browser functionality for specific use cases.
         * @summary ListExtensions
         * @param {string} mode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1ExtensionsGet: async (mode: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mode' is not null or undefined
            assertParamExists('modeV1ExtensionsGet', 'mode', mode)
            const localVarPath = `/{mode}/v1/extensions`
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExtensionsApi - functional programming interface
 * @export
 */
export const ExtensionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExtensionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves detailed information about a specific browser extension, including its name, description, and installation URL.
         * @summary GetExtension
         * @param {string} mode 
         * @param {string} extensionUUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modeV1ExtensionsExtensionUUIDGet(mode: string, extensionUUID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Extension>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modeV1ExtensionsExtensionUUIDGet(mode, extensionUUID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExtensionsApi.modeV1ExtensionsExtensionUUIDGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of all available browser extensions that can be added to fingerprints. These extensions can enhance browser functionality for specific use cases.
         * @summary ListExtensions
         * @param {string} mode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modeV1ExtensionsGet(mode: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModeV1ExtensionsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modeV1ExtensionsGet(mode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExtensionsApi.modeV1ExtensionsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ExtensionsApi - factory interface
 * @export
 */
export const ExtensionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExtensionsApiFp(configuration)
    return {
        /**
         * Retrieves detailed information about a specific browser extension, including its name, description, and installation URL.
         * @summary GetExtension
         * @param {string} mode 
         * @param {string} extensionUUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1ExtensionsExtensionUUIDGet(mode: string, extensionUUID: string, options?: RawAxiosRequestConfig): AxiosPromise<Extension> {
            return localVarFp.modeV1ExtensionsExtensionUUIDGet(mode, extensionUUID, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of all available browser extensions that can be added to fingerprints. These extensions can enhance browser functionality for specific use cases.
         * @summary ListExtensions
         * @param {string} mode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1ExtensionsGet(mode: string, options?: RawAxiosRequestConfig): AxiosPromise<ModeV1ExtensionsGet200Response> {
            return localVarFp.modeV1ExtensionsGet(mode, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExtensionsApi - object-oriented interface
 * @export
 * @class ExtensionsApi
 * @extends {BaseAPI}
 */
export class ExtensionsApi extends BaseAPI {
    /**
     * Retrieves detailed information about a specific browser extension, including its name, description, and installation URL.
     * @summary GetExtension
     * @param {string} mode 
     * @param {string} extensionUUID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtensionsApi
     */
    public modeV1ExtensionsExtensionUUIDGet(mode: string, extensionUUID: string, options?: RawAxiosRequestConfig) {
        return ExtensionsApiFp(this.configuration).modeV1ExtensionsExtensionUUIDGet(mode, extensionUUID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of all available browser extensions that can be added to fingerprints. These extensions can enhance browser functionality for specific use cases.
     * @summary ListExtensions
     * @param {string} mode 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtensionsApi
     */
    public modeV1ExtensionsGet(mode: string, options?: RawAxiosRequestConfig) {
        return ExtensionsApiFp(this.configuration).modeV1ExtensionsGet(mode, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FingerprintsApi - axios parameter creator
 * @export
 */
export const FingerprintsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Archives a fingerprint by deleting all associated session data and marking it as no longer usable. Once archived, the fingerprint cannot be used to create new sessions.
         * @summary ArchiveFingerprint
         * @param {string} mode 
         * @param {string} fingerprintUUID 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1FingerprintsFingerprintUUIDArchivePost: async (mode: string, fingerprintUUID: string, body?: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mode' is not null or undefined
            assertParamExists('modeV1FingerprintsFingerprintUUIDArchivePost', 'mode', mode)
            // verify required parameter 'fingerprintUUID' is not null or undefined
            assertParamExists('modeV1FingerprintsFingerprintUUIDArchivePost', 'fingerprintUUID', fingerprintUUID)
            const localVarPath = `/{mode}/v1/fingerprints/{fingerprintUUID}/archive`
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)))
                .replace(`{${"fingerprintUUID"}}`, encodeURIComponent(String(fingerprintUUID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a copy of an existing fingerprint\'s settings but generates new session data. This allows you to duplicate a successful configuration while maintaining unique session identifiers.
         * @summary CloneFingerprint
         * @param {string} mode 
         * @param {string} fingerprintUUID 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1FingerprintsFingerprintUUIDClonePost: async (mode: string, fingerprintUUID: string, body?: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mode' is not null or undefined
            assertParamExists('modeV1FingerprintsFingerprintUUIDClonePost', 'mode', mode)
            // verify required parameter 'fingerprintUUID' is not null or undefined
            assertParamExists('modeV1FingerprintsFingerprintUUIDClonePost', 'fingerprintUUID', fingerprintUUID)
            const localVarPath = `/{mode}/v1/fingerprints/{fingerprintUUID}/clone`
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)))
                .replace(`{${"fingerprintUUID"}}`, encodeURIComponent(String(fingerprintUUID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves detailed information about a specific fingerprint, including its configuration, proxy settings, and session status.
         * @summary GetFingerprint
         * @param {string} mode 
         * @param {string} fingerprintUUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1FingerprintsFingerprintUUIDGet: async (mode: string, fingerprintUUID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mode' is not null or undefined
            assertParamExists('modeV1FingerprintsFingerprintUUIDGet', 'mode', mode)
            // verify required parameter 'fingerprintUUID' is not null or undefined
            assertParamExists('modeV1FingerprintsFingerprintUUIDGet', 'fingerprintUUID', fingerprintUUID)
            const localVarPath = `/{mode}/v1/fingerprints/{fingerprintUUID}`
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)))
                .replace(`{${"fingerprintUUID"}}`, encodeURIComponent(String(fingerprintUUID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the proxy settings for a specific fingerprint. This allows you to change the geographic location and routing of browser traffic.
         * @summary UpdateFingerprintProxy
         * @param {string} mode 
         * @param {string} fingerprintUUID 
         * @param {UpdateFingerprintProxyRequest} updateFingerprintProxyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1FingerprintsFingerprintUUIDProxyPatch: async (mode: string, fingerprintUUID: string, updateFingerprintProxyRequest: UpdateFingerprintProxyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mode' is not null or undefined
            assertParamExists('modeV1FingerprintsFingerprintUUIDProxyPatch', 'mode', mode)
            // verify required parameter 'fingerprintUUID' is not null or undefined
            assertParamExists('modeV1FingerprintsFingerprintUUIDProxyPatch', 'fingerprintUUID', fingerprintUUID)
            // verify required parameter 'updateFingerprintProxyRequest' is not null or undefined
            assertParamExists('modeV1FingerprintsFingerprintUUIDProxyPatch', 'updateFingerprintProxyRequest', updateFingerprintProxyRequest)
            const localVarPath = `/{mode}/v1/fingerprints/{fingerprintUUID}/proxy`
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)))
                .replace(`{${"fingerprintUUID"}}`, encodeURIComponent(String(fingerprintUUID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateFingerprintProxyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes all session data associated with the fingerprint while preserving its configuration. This allows you to start fresh with the same fingerprint settings.
         * @summary ResetFingerprint
         * @param {string} mode 
         * @param {string} fingerprintUUID 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1FingerprintsFingerprintUUIDResetPost: async (mode: string, fingerprintUUID: string, body?: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mode' is not null or undefined
            assertParamExists('modeV1FingerprintsFingerprintUUIDResetPost', 'mode', mode)
            // verify required parameter 'fingerprintUUID' is not null or undefined
            assertParamExists('modeV1FingerprintsFingerprintUUIDResetPost', 'fingerprintUUID', fingerprintUUID)
            const localVarPath = `/{mode}/v1/fingerprints/{fingerprintUUID}/reset`
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)))
                .replace(`{${"fingerprintUUID"}}`, encodeURIComponent(String(fingerprintUUID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ListFingerprints
         * @param {string} mode 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1FingerprintsGet: async (mode: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mode' is not null or undefined
            assertParamExists('modeV1FingerprintsGet', 'mode', mode)
            const localVarPath = `/{mode}/v1/fingerprints`
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new fingerprint with specified browser configuration, device settings, and proxy settings. This fingerprint can be used to start new browser sessions.
         * @summary CreateFingerprint
         * @param {string} mode 
         * @param {CreateFingerprintRequestBody} createFingerprintRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1FingerprintsPost: async (mode: string, createFingerprintRequestBody: CreateFingerprintRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mode' is not null or undefined
            assertParamExists('modeV1FingerprintsPost', 'mode', mode)
            // verify required parameter 'createFingerprintRequestBody' is not null or undefined
            assertParamExists('modeV1FingerprintsPost', 'createFingerprintRequestBody', createFingerprintRequestBody)
            const localVarPath = `/{mode}/v1/fingerprints`
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createFingerprintRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates a new fingerprint with randomized browser configuration, device settings, and proxy settings.
         * @summary CreateRandomFingerprint
         * @param {string} mode 
         * @param {CreateRandomFingerprintRequest} createRandomFingerprintRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1FingerprintsRandomPost: async (mode: string, createRandomFingerprintRequest: CreateRandomFingerprintRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mode' is not null or undefined
            assertParamExists('modeV1FingerprintsRandomPost', 'mode', mode)
            // verify required parameter 'createRandomFingerprintRequest' is not null or undefined
            assertParamExists('modeV1FingerprintsRandomPost', 'createRandomFingerprintRequest', createRandomFingerprintRequest)
            const localVarPath = `/{mode}/v1/fingerprints/random`
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRandomFingerprintRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FingerprintsApi - functional programming interface
 * @export
 */
export const FingerprintsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FingerprintsApiAxiosParamCreator(configuration)
    return {
        /**
         * Archives a fingerprint by deleting all associated session data and marking it as no longer usable. Once archived, the fingerprint cannot be used to create new sessions.
         * @summary ArchiveFingerprint
         * @param {string} mode 
         * @param {string} fingerprintUUID 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modeV1FingerprintsFingerprintUUIDArchivePost(mode: string, fingerprintUUID: string, body?: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modeV1FingerprintsFingerprintUUIDArchivePost(mode, fingerprintUUID, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FingerprintsApi.modeV1FingerprintsFingerprintUUIDArchivePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a copy of an existing fingerprint\'s settings but generates new session data. This allows you to duplicate a successful configuration while maintaining unique session identifiers.
         * @summary CloneFingerprint
         * @param {string} mode 
         * @param {string} fingerprintUUID 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modeV1FingerprintsFingerprintUUIDClonePost(mode: string, fingerprintUUID: string, body?: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FingerprintWithSecret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modeV1FingerprintsFingerprintUUIDClonePost(mode, fingerprintUUID, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FingerprintsApi.modeV1FingerprintsFingerprintUUIDClonePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves detailed information about a specific fingerprint, including its configuration, proxy settings, and session status.
         * @summary GetFingerprint
         * @param {string} mode 
         * @param {string} fingerprintUUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modeV1FingerprintsFingerprintUUIDGet(mode: string, fingerprintUUID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Fingerprint>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modeV1FingerprintsFingerprintUUIDGet(mode, fingerprintUUID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FingerprintsApi.modeV1FingerprintsFingerprintUUIDGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the proxy settings for a specific fingerprint. This allows you to change the geographic location and routing of browser traffic.
         * @summary UpdateFingerprintProxy
         * @param {string} mode 
         * @param {string} fingerprintUUID 
         * @param {UpdateFingerprintProxyRequest} updateFingerprintProxyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modeV1FingerprintsFingerprintUUIDProxyPatch(mode: string, fingerprintUUID: string, updateFingerprintProxyRequest: UpdateFingerprintProxyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modeV1FingerprintsFingerprintUUIDProxyPatch(mode, fingerprintUUID, updateFingerprintProxyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FingerprintsApi.modeV1FingerprintsFingerprintUUIDProxyPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes all session data associated with the fingerprint while preserving its configuration. This allows you to start fresh with the same fingerprint settings.
         * @summary ResetFingerprint
         * @param {string} mode 
         * @param {string} fingerprintUUID 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modeV1FingerprintsFingerprintUUIDResetPost(mode: string, fingerprintUUID: string, body?: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modeV1FingerprintsFingerprintUUIDResetPost(mode, fingerprintUUID, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FingerprintsApi.modeV1FingerprintsFingerprintUUIDResetPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary ListFingerprints
         * @param {string} mode 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modeV1FingerprintsGet(mode: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModeV1FingerprintsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modeV1FingerprintsGet(mode, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FingerprintsApi.modeV1FingerprintsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new fingerprint with specified browser configuration, device settings, and proxy settings. This fingerprint can be used to start new browser sessions.
         * @summary CreateFingerprint
         * @param {string} mode 
         * @param {CreateFingerprintRequestBody} createFingerprintRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modeV1FingerprintsPost(mode: string, createFingerprintRequestBody: CreateFingerprintRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FingerprintWithSecret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modeV1FingerprintsPost(mode, createFingerprintRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FingerprintsApi.modeV1FingerprintsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generates a new fingerprint with randomized browser configuration, device settings, and proxy settings.
         * @summary CreateRandomFingerprint
         * @param {string} mode 
         * @param {CreateRandomFingerprintRequest} createRandomFingerprintRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modeV1FingerprintsRandomPost(mode: string, createRandomFingerprintRequest: CreateRandomFingerprintRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FingerprintWithSecret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modeV1FingerprintsRandomPost(mode, createRandomFingerprintRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FingerprintsApi.modeV1FingerprintsRandomPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FingerprintsApi - factory interface
 * @export
 */
export const FingerprintsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FingerprintsApiFp(configuration)
    return {
        /**
         * Archives a fingerprint by deleting all associated session data and marking it as no longer usable. Once archived, the fingerprint cannot be used to create new sessions.
         * @summary ArchiveFingerprint
         * @param {string} mode 
         * @param {string} fingerprintUUID 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1FingerprintsFingerprintUUIDArchivePost(mode: string, fingerprintUUID: string, body?: object, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.modeV1FingerprintsFingerprintUUIDArchivePost(mode, fingerprintUUID, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a copy of an existing fingerprint\'s settings but generates new session data. This allows you to duplicate a successful configuration while maintaining unique session identifiers.
         * @summary CloneFingerprint
         * @param {string} mode 
         * @param {string} fingerprintUUID 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1FingerprintsFingerprintUUIDClonePost(mode: string, fingerprintUUID: string, body?: object, options?: RawAxiosRequestConfig): AxiosPromise<FingerprintWithSecret> {
            return localVarFp.modeV1FingerprintsFingerprintUUIDClonePost(mode, fingerprintUUID, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves detailed information about a specific fingerprint, including its configuration, proxy settings, and session status.
         * @summary GetFingerprint
         * @param {string} mode 
         * @param {string} fingerprintUUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1FingerprintsFingerprintUUIDGet(mode: string, fingerprintUUID: string, options?: RawAxiosRequestConfig): AxiosPromise<Fingerprint> {
            return localVarFp.modeV1FingerprintsFingerprintUUIDGet(mode, fingerprintUUID, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the proxy settings for a specific fingerprint. This allows you to change the geographic location and routing of browser traffic.
         * @summary UpdateFingerprintProxy
         * @param {string} mode 
         * @param {string} fingerprintUUID 
         * @param {UpdateFingerprintProxyRequest} updateFingerprintProxyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1FingerprintsFingerprintUUIDProxyPatch(mode: string, fingerprintUUID: string, updateFingerprintProxyRequest: UpdateFingerprintProxyRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.modeV1FingerprintsFingerprintUUIDProxyPatch(mode, fingerprintUUID, updateFingerprintProxyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes all session data associated with the fingerprint while preserving its configuration. This allows you to start fresh with the same fingerprint settings.
         * @summary ResetFingerprint
         * @param {string} mode 
         * @param {string} fingerprintUUID 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1FingerprintsFingerprintUUIDResetPost(mode: string, fingerprintUUID: string, body?: object, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.modeV1FingerprintsFingerprintUUIDResetPost(mode, fingerprintUUID, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ListFingerprints
         * @param {string} mode 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1FingerprintsGet(mode: string, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<ModeV1FingerprintsGet200Response> {
            return localVarFp.modeV1FingerprintsGet(mode, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new fingerprint with specified browser configuration, device settings, and proxy settings. This fingerprint can be used to start new browser sessions.
         * @summary CreateFingerprint
         * @param {string} mode 
         * @param {CreateFingerprintRequestBody} createFingerprintRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1FingerprintsPost(mode: string, createFingerprintRequestBody: CreateFingerprintRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<FingerprintWithSecret> {
            return localVarFp.modeV1FingerprintsPost(mode, createFingerprintRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Generates a new fingerprint with randomized browser configuration, device settings, and proxy settings.
         * @summary CreateRandomFingerprint
         * @param {string} mode 
         * @param {CreateRandomFingerprintRequest} createRandomFingerprintRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1FingerprintsRandomPost(mode: string, createRandomFingerprintRequest: CreateRandomFingerprintRequest, options?: RawAxiosRequestConfig): AxiosPromise<FingerprintWithSecret> {
            return localVarFp.modeV1FingerprintsRandomPost(mode, createRandomFingerprintRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FingerprintsApi - object-oriented interface
 * @export
 * @class FingerprintsApi
 * @extends {BaseAPI}
 */
export class FingerprintsApi extends BaseAPI {
    /**
     * Archives a fingerprint by deleting all associated session data and marking it as no longer usable. Once archived, the fingerprint cannot be used to create new sessions.
     * @summary ArchiveFingerprint
     * @param {string} mode 
     * @param {string} fingerprintUUID 
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FingerprintsApi
     */
    public modeV1FingerprintsFingerprintUUIDArchivePost(mode: string, fingerprintUUID: string, body?: object, options?: RawAxiosRequestConfig) {
        return FingerprintsApiFp(this.configuration).modeV1FingerprintsFingerprintUUIDArchivePost(mode, fingerprintUUID, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a copy of an existing fingerprint\'s settings but generates new session data. This allows you to duplicate a successful configuration while maintaining unique session identifiers.
     * @summary CloneFingerprint
     * @param {string} mode 
     * @param {string} fingerprintUUID 
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FingerprintsApi
     */
    public modeV1FingerprintsFingerprintUUIDClonePost(mode: string, fingerprintUUID: string, body?: object, options?: RawAxiosRequestConfig) {
        return FingerprintsApiFp(this.configuration).modeV1FingerprintsFingerprintUUIDClonePost(mode, fingerprintUUID, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves detailed information about a specific fingerprint, including its configuration, proxy settings, and session status.
     * @summary GetFingerprint
     * @param {string} mode 
     * @param {string} fingerprintUUID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FingerprintsApi
     */
    public modeV1FingerprintsFingerprintUUIDGet(mode: string, fingerprintUUID: string, options?: RawAxiosRequestConfig) {
        return FingerprintsApiFp(this.configuration).modeV1FingerprintsFingerprintUUIDGet(mode, fingerprintUUID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the proxy settings for a specific fingerprint. This allows you to change the geographic location and routing of browser traffic.
     * @summary UpdateFingerprintProxy
     * @param {string} mode 
     * @param {string} fingerprintUUID 
     * @param {UpdateFingerprintProxyRequest} updateFingerprintProxyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FingerprintsApi
     */
    public modeV1FingerprintsFingerprintUUIDProxyPatch(mode: string, fingerprintUUID: string, updateFingerprintProxyRequest: UpdateFingerprintProxyRequest, options?: RawAxiosRequestConfig) {
        return FingerprintsApiFp(this.configuration).modeV1FingerprintsFingerprintUUIDProxyPatch(mode, fingerprintUUID, updateFingerprintProxyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes all session data associated with the fingerprint while preserving its configuration. This allows you to start fresh with the same fingerprint settings.
     * @summary ResetFingerprint
     * @param {string} mode 
     * @param {string} fingerprintUUID 
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FingerprintsApi
     */
    public modeV1FingerprintsFingerprintUUIDResetPost(mode: string, fingerprintUUID: string, body?: object, options?: RawAxiosRequestConfig) {
        return FingerprintsApiFp(this.configuration).modeV1FingerprintsFingerprintUUIDResetPost(mode, fingerprintUUID, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ListFingerprints
     * @param {string} mode 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FingerprintsApi
     */
    public modeV1FingerprintsGet(mode: string, limit?: number, options?: RawAxiosRequestConfig) {
        return FingerprintsApiFp(this.configuration).modeV1FingerprintsGet(mode, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new fingerprint with specified browser configuration, device settings, and proxy settings. This fingerprint can be used to start new browser sessions.
     * @summary CreateFingerprint
     * @param {string} mode 
     * @param {CreateFingerprintRequestBody} createFingerprintRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FingerprintsApi
     */
    public modeV1FingerprintsPost(mode: string, createFingerprintRequestBody: CreateFingerprintRequestBody, options?: RawAxiosRequestConfig) {
        return FingerprintsApiFp(this.configuration).modeV1FingerprintsPost(mode, createFingerprintRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generates a new fingerprint with randomized browser configuration, device settings, and proxy settings.
     * @summary CreateRandomFingerprint
     * @param {string} mode 
     * @param {CreateRandomFingerprintRequest} createRandomFingerprintRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FingerprintsApi
     */
    public modeV1FingerprintsRandomPost(mode: string, createRandomFingerprintRequest: CreateRandomFingerprintRequest, options?: RawAxiosRequestConfig) {
        return FingerprintsApiFp(this.configuration).modeV1FingerprintsRandomPost(mode, createRandomFingerprintRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OperatorsApi - axios parameter creator
 * @export
 */
export const OperatorsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves information about all operators and total browser count
         * @summary Get operators information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OperatorsInfoGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/operators/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of all available operators
         * @summary List all operators
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OperatorsListAllGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/operators/listAll`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves detailed information about a specific operator
         * @summary Get operator information
         * @param {string} operatorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OperatorsOperatorIdInfoGet: async (operatorId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('v1OperatorsOperatorIdInfoGet', 'operatorId', operatorId)
            const localVarPath = `/v1/operators/{operatorId}/info`
                .replace(`{${"operatorId"}}`, encodeURIComponent(String(operatorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a random operator ID
         * @summary Get random operator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OperatorsRandomGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/operators/random`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OperatorsApi - functional programming interface
 * @export
 */
export const OperatorsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OperatorsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves information about all operators and total browser count
         * @summary Get operators information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OperatorsInfoGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1OperatorsInfoGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OperatorsInfoGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperatorsApi.v1OperatorsInfoGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of all available operators
         * @summary List all operators
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OperatorsListAllGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1OperatorsListAllGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OperatorsListAllGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperatorsApi.v1OperatorsListAllGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves detailed information about a specific operator
         * @summary Get operator information
         * @param {string} operatorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OperatorsOperatorIdInfoGet(operatorId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Operator>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OperatorsOperatorIdInfoGet(operatorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperatorsApi.v1OperatorsOperatorIdInfoGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a random operator ID
         * @summary Get random operator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OperatorsRandomGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1OperatorsRandomGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OperatorsRandomGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperatorsApi.v1OperatorsRandomGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OperatorsApi - factory interface
 * @export
 */
export const OperatorsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OperatorsApiFp(configuration)
    return {
        /**
         * Retrieves information about all operators and total browser count
         * @summary Get operators information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OperatorsInfoGet(options?: RawAxiosRequestConfig): AxiosPromise<V1OperatorsInfoGet200Response> {
            return localVarFp.v1OperatorsInfoGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of all available operators
         * @summary List all operators
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OperatorsListAllGet(options?: RawAxiosRequestConfig): AxiosPromise<V1OperatorsListAllGet200Response> {
            return localVarFp.v1OperatorsListAllGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves detailed information about a specific operator
         * @summary Get operator information
         * @param {string} operatorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OperatorsOperatorIdInfoGet(operatorId: string, options?: RawAxiosRequestConfig): AxiosPromise<Operator> {
            return localVarFp.v1OperatorsOperatorIdInfoGet(operatorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a random operator ID
         * @summary Get random operator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OperatorsRandomGet(options?: RawAxiosRequestConfig): AxiosPromise<V1OperatorsRandomGet200Response> {
            return localVarFp.v1OperatorsRandomGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OperatorsApi - object-oriented interface
 * @export
 * @class OperatorsApi
 * @extends {BaseAPI}
 */
export class OperatorsApi extends BaseAPI {
    /**
     * Retrieves information about all operators and total browser count
     * @summary Get operators information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorsApi
     */
    public v1OperatorsInfoGet(options?: RawAxiosRequestConfig) {
        return OperatorsApiFp(this.configuration).v1OperatorsInfoGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of all available operators
     * @summary List all operators
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorsApi
     */
    public v1OperatorsListAllGet(options?: RawAxiosRequestConfig) {
        return OperatorsApiFp(this.configuration).v1OperatorsListAllGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves detailed information about a specific operator
     * @summary Get operator information
     * @param {string} operatorId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorsApi
     */
    public v1OperatorsOperatorIdInfoGet(operatorId: string, options?: RawAxiosRequestConfig) {
        return OperatorsApiFp(this.configuration).v1OperatorsOperatorIdInfoGet(operatorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a random operator ID
     * @summary Get random operator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorsApi
     */
    public v1OperatorsRandomGet(options?: RawAxiosRequestConfig) {
        return OperatorsApiFp(this.configuration).v1OperatorsRandomGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PageApi - axios parameter creator
 * @export
 */
export const PageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Close page by index
         * @param {string} mode 
         * @param {ClosePageRequestBody} closePageRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1PageClosePagePost: async (mode: string, closePageRequestBody: ClosePageRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mode' is not null or undefined
            assertParamExists('modeV1PageClosePagePost', 'mode', mode)
            // verify required parameter 'closePageRequestBody' is not null or undefined
            assertParamExists('modeV1PageClosePagePost', 'closePageRequestBody', closePageRequestBody)
            const localVarPath = `/{mode}/v1/page/closePage`
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(closePageRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Executes a sequence of browser automation commands within an active session. Supports various actions like clicking, typing, hovering, and more.
         * @summary Execute browser commands
         * @param {string} mode 
         * @param {ModeV1PageExecuteCommandsPostRequest} modeV1PageExecuteCommandsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1PageExecuteCommandsPost: async (mode: string, modeV1PageExecuteCommandsPostRequest: ModeV1PageExecuteCommandsPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mode' is not null or undefined
            assertParamExists('modeV1PageExecuteCommandsPost', 'mode', mode)
            // verify required parameter 'modeV1PageExecuteCommandsPostRequest' is not null or undefined
            assertParamExists('modeV1PageExecuteCommandsPost', 'modeV1PageExecuteCommandsPostRequest', modeV1PageExecuteCommandsPostRequest)
            const localVarPath = `/{mode}/v1/page/executeCommands`
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(modeV1PageExecuteCommandsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Extract data from page using AI
         * @param {string} mode 
         * @param {ExtractRequestBody} extractRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1PageExtractPost: async (mode: string, extractRequestBody: ExtractRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mode' is not null or undefined
            assertParamExists('modeV1PageExtractPost', 'mode', mode)
            // verify required parameter 'extractRequestBody' is not null or undefined
            assertParamExists('modeV1PageExtractPost', 'extractRequestBody', extractRequestBody)
            const localVarPath = `/{mode}/v1/page/extract`
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(extractRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Navigate back in browser history
         * @param {string} mode 
         * @param {GoBackRequestBody} goBackRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1PageGoBackPost: async (mode: string, goBackRequestBody: GoBackRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mode' is not null or undefined
            assertParamExists('modeV1PageGoBackPost', 'mode', mode)
            // verify required parameter 'goBackRequestBody' is not null or undefined
            assertParamExists('modeV1PageGoBackPost', 'goBackRequestBody', goBackRequestBody)
            const localVarPath = `/{mode}/v1/page/goBack`
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(goBackRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary goToPage
         * @param {string} mode 
         * @param {ModeV1PageGoToPagePostRequest} modeV1PageGoToPagePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1PageGoToPagePost: async (mode: string, modeV1PageGoToPagePostRequest: ModeV1PageGoToPagePostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mode' is not null or undefined
            assertParamExists('modeV1PageGoToPagePost', 'mode', mode)
            // verify required parameter 'modeV1PageGoToPagePostRequest' is not null or undefined
            assertParamExists('modeV1PageGoToPagePost', 'modeV1PageGoToPagePostRequest', modeV1PageGoToPagePostRequest)
            const localVarPath = `/{mode}/v1/page/goToPage`
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(modeV1PageGoToPagePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get page content as markdown
         * @param {string} mode 
         * @param {MarkdownRequestBody} markdownRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1PageMarkdownPost: async (mode: string, markdownRequestBody: MarkdownRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mode' is not null or undefined
            assertParamExists('modeV1PageMarkdownPost', 'mode', mode)
            // verify required parameter 'markdownRequestBody' is not null or undefined
            assertParamExists('modeV1PageMarkdownPost', 'markdownRequestBody', markdownRequestBody)
            const localVarPath = `/{mode}/v1/page/markdown`
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(markdownRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new page/tab
         * @param {string} mode 
         * @param {NewPageRequestBody} newPageRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1PageNewPagePost: async (mode: string, newPageRequestBody: NewPageRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mode' is not null or undefined
            assertParamExists('modeV1PageNewPagePost', 'mode', mode)
            // verify required parameter 'newPageRequestBody' is not null or undefined
            assertParamExists('modeV1PageNewPagePost', 'newPageRequestBody', newPageRequestBody)
            const localVarPath = `/{mode}/v1/page/newPage`
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newPageRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Generate PDF of current page
         * @param {string} mode 
         * @param {PdfRequestBody} pdfRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1PagePdfPost: async (mode: string, pdfRequestBody: PdfRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mode' is not null or undefined
            assertParamExists('modeV1PagePdfPost', 'mode', mode)
            // verify required parameter 'pdfRequestBody' is not null or undefined
            assertParamExists('modeV1PagePdfPost', 'pdfRequestBody', pdfRequestBody)
            const localVarPath = `/{mode}/v1/page/pdf`
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pdfRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Switch to page by index
         * @param {string} mode 
         * @param {SwitchPageRequestBody} switchPageRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1PageSwitchPagePost: async (mode: string, switchPageRequestBody: SwitchPageRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mode' is not null or undefined
            assertParamExists('modeV1PageSwitchPagePost', 'mode', mode)
            // verify required parameter 'switchPageRequestBody' is not null or undefined
            assertParamExists('modeV1PageSwitchPagePost', 'switchPageRequestBody', switchPageRequestBody)
            const localVarPath = `/{mode}/v1/page/switchPage`
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(switchPageRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PageApi - functional programming interface
 * @export
 */
export const PageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PageApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Close page by index
         * @param {string} mode 
         * @param {ClosePageRequestBody} closePageRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modeV1PageClosePagePost(mode: string, closePageRequestBody: ClosePageRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modeV1PageClosePagePost(mode, closePageRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PageApi.modeV1PageClosePagePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Executes a sequence of browser automation commands within an active session. Supports various actions like clicking, typing, hovering, and more.
         * @summary Execute browser commands
         * @param {string} mode 
         * @param {ModeV1PageExecuteCommandsPostRequest} modeV1PageExecuteCommandsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modeV1PageExecuteCommandsPost(mode: string, modeV1PageExecuteCommandsPostRequest: ModeV1PageExecuteCommandsPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modeV1PageExecuteCommandsPost(mode, modeV1PageExecuteCommandsPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PageApi.modeV1PageExecuteCommandsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Extract data from page using AI
         * @param {string} mode 
         * @param {ExtractRequestBody} extractRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modeV1PageExtractPost(mode: string, extractRequestBody: ExtractRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modeV1PageExtractPost(mode, extractRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PageApi.modeV1PageExtractPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Navigate back in browser history
         * @param {string} mode 
         * @param {GoBackRequestBody} goBackRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modeV1PageGoBackPost(mode: string, goBackRequestBody: GoBackRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modeV1PageGoBackPost(mode, goBackRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PageApi.modeV1PageGoBackPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary goToPage
         * @param {string} mode 
         * @param {ModeV1PageGoToPagePostRequest} modeV1PageGoToPagePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modeV1PageGoToPagePost(mode: string, modeV1PageGoToPagePostRequest: ModeV1PageGoToPagePostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modeV1PageGoToPagePost(mode, modeV1PageGoToPagePostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PageApi.modeV1PageGoToPagePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get page content as markdown
         * @param {string} mode 
         * @param {MarkdownRequestBody} markdownRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modeV1PageMarkdownPost(mode: string, markdownRequestBody: MarkdownRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MarkdownResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modeV1PageMarkdownPost(mode, markdownRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PageApi.modeV1PageMarkdownPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create new page/tab
         * @param {string} mode 
         * @param {NewPageRequestBody} newPageRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modeV1PageNewPagePost(mode: string, newPageRequestBody: NewPageRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modeV1PageNewPagePost(mode, newPageRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PageApi.modeV1PageNewPagePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Generate PDF of current page
         * @param {string} mode 
         * @param {PdfRequestBody} pdfRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modeV1PagePdfPost(mode: string, pdfRequestBody: PdfRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PdfResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modeV1PagePdfPost(mode, pdfRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PageApi.modeV1PagePdfPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Switch to page by index
         * @param {string} mode 
         * @param {SwitchPageRequestBody} switchPageRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modeV1PageSwitchPagePost(mode: string, switchPageRequestBody: SwitchPageRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modeV1PageSwitchPagePost(mode, switchPageRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PageApi.modeV1PageSwitchPagePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PageApi - factory interface
 * @export
 */
export const PageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PageApiFp(configuration)
    return {
        /**
         * 
         * @summary Close page by index
         * @param {string} mode 
         * @param {ClosePageRequestBody} closePageRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1PageClosePagePost(mode: string, closePageRequestBody: ClosePageRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.modeV1PageClosePagePost(mode, closePageRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Executes a sequence of browser automation commands within an active session. Supports various actions like clicking, typing, hovering, and more.
         * @summary Execute browser commands
         * @param {string} mode 
         * @param {ModeV1PageExecuteCommandsPostRequest} modeV1PageExecuteCommandsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1PageExecuteCommandsPost(mode: string, modeV1PageExecuteCommandsPostRequest: ModeV1PageExecuteCommandsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.modeV1PageExecuteCommandsPost(mode, modeV1PageExecuteCommandsPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Extract data from page using AI
         * @param {string} mode 
         * @param {ExtractRequestBody} extractRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1PageExtractPost(mode: string, extractRequestBody: ExtractRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.modeV1PageExtractPost(mode, extractRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Navigate back in browser history
         * @param {string} mode 
         * @param {GoBackRequestBody} goBackRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1PageGoBackPost(mode: string, goBackRequestBody: GoBackRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<PageInfoResponse> {
            return localVarFp.modeV1PageGoBackPost(mode, goBackRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary goToPage
         * @param {string} mode 
         * @param {ModeV1PageGoToPagePostRequest} modeV1PageGoToPagePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1PageGoToPagePost(mode: string, modeV1PageGoToPagePostRequest: ModeV1PageGoToPagePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.modeV1PageGoToPagePost(mode, modeV1PageGoToPagePostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get page content as markdown
         * @param {string} mode 
         * @param {MarkdownRequestBody} markdownRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1PageMarkdownPost(mode: string, markdownRequestBody: MarkdownRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<MarkdownResponse> {
            return localVarFp.modeV1PageMarkdownPost(mode, markdownRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create new page/tab
         * @param {string} mode 
         * @param {NewPageRequestBody} newPageRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1PageNewPagePost(mode: string, newPageRequestBody: NewPageRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.modeV1PageNewPagePost(mode, newPageRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Generate PDF of current page
         * @param {string} mode 
         * @param {PdfRequestBody} pdfRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1PagePdfPost(mode: string, pdfRequestBody: PdfRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<PdfResponse> {
            return localVarFp.modeV1PagePdfPost(mode, pdfRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Switch to page by index
         * @param {string} mode 
         * @param {SwitchPageRequestBody} switchPageRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1PageSwitchPagePost(mode: string, switchPageRequestBody: SwitchPageRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.modeV1PageSwitchPagePost(mode, switchPageRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PageApi - object-oriented interface
 * @export
 * @class PageApi
 * @extends {BaseAPI}
 */
export class PageApi extends BaseAPI {
    /**
     * 
     * @summary Close page by index
     * @param {string} mode 
     * @param {ClosePageRequestBody} closePageRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public modeV1PageClosePagePost(mode: string, closePageRequestBody: ClosePageRequestBody, options?: RawAxiosRequestConfig) {
        return PageApiFp(this.configuration).modeV1PageClosePagePost(mode, closePageRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Executes a sequence of browser automation commands within an active session. Supports various actions like clicking, typing, hovering, and more.
     * @summary Execute browser commands
     * @param {string} mode 
     * @param {ModeV1PageExecuteCommandsPostRequest} modeV1PageExecuteCommandsPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public modeV1PageExecuteCommandsPost(mode: string, modeV1PageExecuteCommandsPostRequest: ModeV1PageExecuteCommandsPostRequest, options?: RawAxiosRequestConfig) {
        return PageApiFp(this.configuration).modeV1PageExecuteCommandsPost(mode, modeV1PageExecuteCommandsPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Extract data from page using AI
     * @param {string} mode 
     * @param {ExtractRequestBody} extractRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public modeV1PageExtractPost(mode: string, extractRequestBody: ExtractRequestBody, options?: RawAxiosRequestConfig) {
        return PageApiFp(this.configuration).modeV1PageExtractPost(mode, extractRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Navigate back in browser history
     * @param {string} mode 
     * @param {GoBackRequestBody} goBackRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public modeV1PageGoBackPost(mode: string, goBackRequestBody: GoBackRequestBody, options?: RawAxiosRequestConfig) {
        return PageApiFp(this.configuration).modeV1PageGoBackPost(mode, goBackRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary goToPage
     * @param {string} mode 
     * @param {ModeV1PageGoToPagePostRequest} modeV1PageGoToPagePostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public modeV1PageGoToPagePost(mode: string, modeV1PageGoToPagePostRequest: ModeV1PageGoToPagePostRequest, options?: RawAxiosRequestConfig) {
        return PageApiFp(this.configuration).modeV1PageGoToPagePost(mode, modeV1PageGoToPagePostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get page content as markdown
     * @param {string} mode 
     * @param {MarkdownRequestBody} markdownRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public modeV1PageMarkdownPost(mode: string, markdownRequestBody: MarkdownRequestBody, options?: RawAxiosRequestConfig) {
        return PageApiFp(this.configuration).modeV1PageMarkdownPost(mode, markdownRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create new page/tab
     * @param {string} mode 
     * @param {NewPageRequestBody} newPageRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public modeV1PageNewPagePost(mode: string, newPageRequestBody: NewPageRequestBody, options?: RawAxiosRequestConfig) {
        return PageApiFp(this.configuration).modeV1PageNewPagePost(mode, newPageRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Generate PDF of current page
     * @param {string} mode 
     * @param {PdfRequestBody} pdfRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public modeV1PagePdfPost(mode: string, pdfRequestBody: PdfRequestBody, options?: RawAxiosRequestConfig) {
        return PageApiFp(this.configuration).modeV1PagePdfPost(mode, pdfRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Switch to page by index
     * @param {string} mode 
     * @param {SwitchPageRequestBody} switchPageRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public modeV1PageSwitchPagePost(mode: string, switchPageRequestBody: SwitchPageRequestBody, options?: RawAxiosRequestConfig) {
        return PageApiFp(this.configuration).modeV1PageSwitchPagePost(mode, switchPageRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProxyApi - axios parameter creator
 * @export
 */
export const ProxyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Proxy DELETE for unknown paths
         * @param {string} mode 
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1ProxyPathDelete: async (mode: string, path: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mode' is not null or undefined
            assertParamExists('modeV1ProxyPathDelete', 'mode', mode)
            // verify required parameter 'path' is not null or undefined
            assertParamExists('modeV1ProxyPathDelete', 'path', path)
            const localVarPath = `/{mode}/v1/proxy/{path}`
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)))
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Proxy GET for unknown paths
         * @param {string} mode 
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1ProxyPathGet: async (mode: string, path: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mode' is not null or undefined
            assertParamExists('modeV1ProxyPathGet', 'mode', mode)
            // verify required parameter 'path' is not null or undefined
            assertParamExists('modeV1ProxyPathGet', 'path', path)
            const localVarPath = `/{mode}/v1/proxy/{path}`
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)))
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Flexible endpoint that can handle any path, body, and response
         * @summary Proxy endpoint for unknown paths
         * @param {string} mode 
         * @param {string} path Any dynamic path
         * @param {{ [key: string]: any; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1ProxyPathPost: async (mode: string, path: string, requestBody?: { [key: string]: any; }, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mode' is not null or undefined
            assertParamExists('modeV1ProxyPathPost', 'mode', mode)
            // verify required parameter 'path' is not null or undefined
            assertParamExists('modeV1ProxyPathPost', 'path', path)
            const localVarPath = `/{mode}/v1/proxy/{path}`
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)))
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Proxy PUT for unknown paths
         * @param {string} mode 
         * @param {string} path 
         * @param {{ [key: string]: any; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1ProxyPathPut: async (mode: string, path: string, requestBody?: { [key: string]: any; }, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mode' is not null or undefined
            assertParamExists('modeV1ProxyPathPut', 'mode', mode)
            // verify required parameter 'path' is not null or undefined
            assertParamExists('modeV1ProxyPathPut', 'path', path)
            const localVarPath = `/{mode}/v1/proxy/{path}`
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)))
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProxyApi - functional programming interface
 * @export
 */
export const ProxyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProxyApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Proxy DELETE for unknown paths
         * @param {string} mode 
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modeV1ProxyPathDelete(mode: string, path: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modeV1ProxyPathDelete(mode, path, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProxyApi.modeV1ProxyPathDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Proxy GET for unknown paths
         * @param {string} mode 
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modeV1ProxyPathGet(mode: string, path: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modeV1ProxyPathGet(mode, path, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProxyApi.modeV1ProxyPathGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Flexible endpoint that can handle any path, body, and response
         * @summary Proxy endpoint for unknown paths
         * @param {string} mode 
         * @param {string} path Any dynamic path
         * @param {{ [key: string]: any; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modeV1ProxyPathPost(mode: string, path: string, requestBody?: { [key: string]: any; }, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modeV1ProxyPathPost(mode, path, requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProxyApi.modeV1ProxyPathPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Proxy PUT for unknown paths
         * @param {string} mode 
         * @param {string} path 
         * @param {{ [key: string]: any; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modeV1ProxyPathPut(mode: string, path: string, requestBody?: { [key: string]: any; }, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modeV1ProxyPathPut(mode, path, requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProxyApi.modeV1ProxyPathPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProxyApi - factory interface
 * @export
 */
export const ProxyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProxyApiFp(configuration)
    return {
        /**
         * 
         * @summary Proxy DELETE for unknown paths
         * @param {string} mode 
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1ProxyPathDelete(mode: string, path: string, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.modeV1ProxyPathDelete(mode, path, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Proxy GET for unknown paths
         * @param {string} mode 
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1ProxyPathGet(mode: string, path: string, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.modeV1ProxyPathGet(mode, path, options).then((request) => request(axios, basePath));
        },
        /**
         * Flexible endpoint that can handle any path, body, and response
         * @summary Proxy endpoint for unknown paths
         * @param {string} mode 
         * @param {string} path Any dynamic path
         * @param {{ [key: string]: any; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1ProxyPathPost(mode: string, path: string, requestBody?: { [key: string]: any; }, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.modeV1ProxyPathPost(mode, path, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Proxy PUT for unknown paths
         * @param {string} mode 
         * @param {string} path 
         * @param {{ [key: string]: any; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1ProxyPathPut(mode: string, path: string, requestBody?: { [key: string]: any; }, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.modeV1ProxyPathPut(mode, path, requestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProxyApi - object-oriented interface
 * @export
 * @class ProxyApi
 * @extends {BaseAPI}
 */
export class ProxyApi extends BaseAPI {
    /**
     * 
     * @summary Proxy DELETE for unknown paths
     * @param {string} mode 
     * @param {string} path 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProxyApi
     */
    public modeV1ProxyPathDelete(mode: string, path: string, options?: RawAxiosRequestConfig) {
        return ProxyApiFp(this.configuration).modeV1ProxyPathDelete(mode, path, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Proxy GET for unknown paths
     * @param {string} mode 
     * @param {string} path 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProxyApi
     */
    public modeV1ProxyPathGet(mode: string, path: string, options?: RawAxiosRequestConfig) {
        return ProxyApiFp(this.configuration).modeV1ProxyPathGet(mode, path, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Flexible endpoint that can handle any path, body, and response
     * @summary Proxy endpoint for unknown paths
     * @param {string} mode 
     * @param {string} path Any dynamic path
     * @param {{ [key: string]: any; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProxyApi
     */
    public modeV1ProxyPathPost(mode: string, path: string, requestBody?: { [key: string]: any; }, options?: RawAxiosRequestConfig) {
        return ProxyApiFp(this.configuration).modeV1ProxyPathPost(mode, path, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Proxy PUT for unknown paths
     * @param {string} mode 
     * @param {string} path 
     * @param {{ [key: string]: any; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProxyApi
     */
    public modeV1ProxyPathPut(mode: string, path: string, requestBody?: { [key: string]: any; }, options?: RawAxiosRequestConfig) {
        return ProxyApiFp(this.configuration).modeV1ProxyPathPut(mode, path, requestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SessionsApi - axios parameter creator
 * @export
 */
export const SessionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Download file from session
         * @param {string} mode 
         * @param {string} sessionUUID 
         * @param {DownloadFileRequestBody} downloadFileRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1SessionSessionUUIDDownloadFilePost: async (mode: string, sessionUUID: string, downloadFileRequestBody: DownloadFileRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mode' is not null or undefined
            assertParamExists('modeV1SessionSessionUUIDDownloadFilePost', 'mode', mode)
            // verify required parameter 'sessionUUID' is not null or undefined
            assertParamExists('modeV1SessionSessionUUIDDownloadFilePost', 'sessionUUID', sessionUUID)
            // verify required parameter 'downloadFileRequestBody' is not null or undefined
            assertParamExists('modeV1SessionSessionUUIDDownloadFilePost', 'downloadFileRequestBody', downloadFileRequestBody)
            const localVarPath = `/{mode}/v1/session/{sessionUUID}/downloadFile`
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)))
                .replace(`{${"sessionUUID"}}`, encodeURIComponent(String(sessionUUID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(downloadFileRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of session files
         * @param {string} mode 
         * @param {string} sessionUUID 
         * @param {ModeV1SessionSessionUUIDFilesGetTypeEnum} type Type of files to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1SessionSessionUUIDFilesGet: async (mode: string, sessionUUID: string, type: ModeV1SessionSessionUUIDFilesGetTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mode' is not null or undefined
            assertParamExists('modeV1SessionSessionUUIDFilesGet', 'mode', mode)
            // verify required parameter 'sessionUUID' is not null or undefined
            assertParamExists('modeV1SessionSessionUUIDFilesGet', 'sessionUUID', sessionUUID)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('modeV1SessionSessionUUIDFilesGet', 'type', type)
            const localVarPath = `/{mode}/v1/session/{sessionUUID}/files`
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)))
                .replace(`{${"sessionUUID"}}`, encodeURIComponent(String(sessionUUID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload file to session
         * @param {string} mode 
         * @param {string} sessionUUID 
         * @param {UploadFileRequestBody} uploadFileRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1SessionSessionUUIDUploadFilePost: async (mode: string, sessionUUID: string, uploadFileRequestBody: UploadFileRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mode' is not null or undefined
            assertParamExists('modeV1SessionSessionUUIDUploadFilePost', 'mode', mode)
            // verify required parameter 'sessionUUID' is not null or undefined
            assertParamExists('modeV1SessionSessionUUIDUploadFilePost', 'sessionUUID', sessionUUID)
            // verify required parameter 'uploadFileRequestBody' is not null or undefined
            assertParamExists('modeV1SessionSessionUUIDUploadFilePost', 'uploadFileRequestBody', uploadFileRequestBody)
            const localVarPath = `/{mode}/v1/session/{sessionUUID}/uploadFile`
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)))
                .replace(`{${"sessionUUID"}}`, encodeURIComponent(String(sessionUUID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uploadFileRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Grant control to VNC client
         * @param {string} mode 
         * @param {string} sessionUUID 
         * @param {string} clientId 
         * @param {VncClientControlRequestBody} vncClientControlRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1SessionSessionUUIDVncClientsClientIdGrantControlPost: async (mode: string, sessionUUID: string, clientId: string, vncClientControlRequestBody: VncClientControlRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mode' is not null or undefined
            assertParamExists('modeV1SessionSessionUUIDVncClientsClientIdGrantControlPost', 'mode', mode)
            // verify required parameter 'sessionUUID' is not null or undefined
            assertParamExists('modeV1SessionSessionUUIDVncClientsClientIdGrantControlPost', 'sessionUUID', sessionUUID)
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('modeV1SessionSessionUUIDVncClientsClientIdGrantControlPost', 'clientId', clientId)
            // verify required parameter 'vncClientControlRequestBody' is not null or undefined
            assertParamExists('modeV1SessionSessionUUIDVncClientsClientIdGrantControlPost', 'vncClientControlRequestBody', vncClientControlRequestBody)
            const localVarPath = `/{mode}/v1/session/{sessionUUID}/vnc/clients/{clientId}/grantControl`
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)))
                .replace(`{${"sessionUUID"}}`, encodeURIComponent(String(sessionUUID)))
                .replace(`{${"clientId"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vncClientControlRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove control from VNC client
         * @param {string} mode 
         * @param {string} sessionUUID 
         * @param {string} clientId 
         * @param {VncClientControlRequestBody} vncClientControlRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1SessionSessionUUIDVncClientsClientIdRemoveControlDelete: async (mode: string, sessionUUID: string, clientId: string, vncClientControlRequestBody: VncClientControlRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mode' is not null or undefined
            assertParamExists('modeV1SessionSessionUUIDVncClientsClientIdRemoveControlDelete', 'mode', mode)
            // verify required parameter 'sessionUUID' is not null or undefined
            assertParamExists('modeV1SessionSessionUUIDVncClientsClientIdRemoveControlDelete', 'sessionUUID', sessionUUID)
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('modeV1SessionSessionUUIDVncClientsClientIdRemoveControlDelete', 'clientId', clientId)
            // verify required parameter 'vncClientControlRequestBody' is not null or undefined
            assertParamExists('modeV1SessionSessionUUIDVncClientsClientIdRemoveControlDelete', 'vncClientControlRequestBody', vncClientControlRequestBody)
            const localVarPath = `/{mode}/v1/session/{sessionUUID}/vnc/clients/{clientId}/removeControl`
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)))
                .replace(`{${"sessionUUID"}}`, encodeURIComponent(String(sessionUUID)))
                .replace(`{${"clientId"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vncClientControlRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of VNC clients
         * @param {string} mode 
         * @param {string} sessionUUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1SessionSessionUUIDVncClientsGet: async (mode: string, sessionUUID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mode' is not null or undefined
            assertParamExists('modeV1SessionSessionUUIDVncClientsGet', 'mode', mode)
            // verify required parameter 'sessionUUID' is not null or undefined
            assertParamExists('modeV1SessionSessionUUIDVncClientsGet', 'sessionUUID', sessionUUID)
            const localVarPath = `/{mode}/v1/session/{sessionUUID}/vnc/clients`
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)))
                .replace(`{${"sessionUUID"}}`, encodeURIComponent(String(sessionUUID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register VNC API key
         * @param {string} mode 
         * @param {string} sessionUUID 
         * @param {RegisterApiKeyRequestBody} registerApiKeyRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1SessionSessionUUIDVncRegisterApiKeyPost: async (mode: string, sessionUUID: string, registerApiKeyRequestBody: RegisterApiKeyRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mode' is not null or undefined
            assertParamExists('modeV1SessionSessionUUIDVncRegisterApiKeyPost', 'mode', mode)
            // verify required parameter 'sessionUUID' is not null or undefined
            assertParamExists('modeV1SessionSessionUUIDVncRegisterApiKeyPost', 'sessionUUID', sessionUUID)
            // verify required parameter 'registerApiKeyRequestBody' is not null or undefined
            assertParamExists('modeV1SessionSessionUUIDVncRegisterApiKeyPost', 'registerApiKeyRequestBody', registerApiKeyRequestBody)
            const localVarPath = `/{mode}/v1/session/{sessionUUID}/vnc/registerApiKey`
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)))
                .replace(`{${"sessionUUID"}}`, encodeURIComponent(String(sessionUUID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerApiKeyRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of all active browser sessions in your environment, including their status, VNC settings, and lease times.
         * @summary ListSessions
         * @param {string} mode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1SessionsGet: async (mode: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mode' is not null or undefined
            assertParamExists('modeV1SessionsGet', 'mode', mode)
            const localVarPath = `/{mode}/v1/sessions`
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new browser session using a specified fingerprint (OPTIONAL). Configure VNC access, lease time, and other session parameters.
         * @summary CreateSessionWithoutFingerprint
         * @param {string} mode 
         * @param {CreateSessionRequestBody} createSessionRequestBody 
         * @param {string} [xFingerprintSecret] 
         * @param {string} [xEnvironmentId] 
         * @param {string} [xEnvironmentSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1SessionsPost: async (mode: string, createSessionRequestBody: CreateSessionRequestBody, xFingerprintSecret?: string, xEnvironmentId?: string, xEnvironmentSecret?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mode' is not null or undefined
            assertParamExists('modeV1SessionsPost', 'mode', mode)
            // verify required parameter 'createSessionRequestBody' is not null or undefined
            assertParamExists('modeV1SessionsPost', 'createSessionRequestBody', createSessionRequestBody)
            const localVarPath = `/{mode}/v1/sessions`
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xFingerprintSecret != null) {
                localVarHeaderParameter['X-Fingerprint-Secret'] = String(xFingerprintSecret);
            }
            if (xEnvironmentId != null) {
                localVarHeaderParameter['X-Environment-Id'] = String(xEnvironmentId);
            }
            if (xEnvironmentSecret != null) {
                localVarHeaderParameter['X-Environment-Secret'] = String(xEnvironmentSecret);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createSessionRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Terminates a browser session immediately, releasing all associated resources and ending the lease.
         * @summary EndSession
         * @param {string} mode 
         * @param {string} sessionUUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1SessionsSessionUUIDDelete: async (mode: string, sessionUUID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mode' is not null or undefined
            assertParamExists('modeV1SessionsSessionUUIDDelete', 'mode', mode)
            // verify required parameter 'sessionUUID' is not null or undefined
            assertParamExists('modeV1SessionsSessionUUIDDelete', 'sessionUUID', sessionUUID)
            const localVarPath = `/{mode}/v1/sessions/{sessionUUID}`
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)))
                .replace(`{${"sessionUUID"}}`, encodeURIComponent(String(sessionUUID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves detailed information about a specific browser session, including its status, settings, and remaining lease time.
         * @summary GetSession
         * @param {string} mode 
         * @param {string} sessionUUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1SessionsSessionUUIDGet: async (mode: string, sessionUUID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mode' is not null or undefined
            assertParamExists('modeV1SessionsSessionUUIDGet', 'mode', mode)
            // verify required parameter 'sessionUUID' is not null or undefined
            assertParamExists('modeV1SessionsSessionUUIDGet', 'sessionUUID', sessionUUID)
            const localVarPath = `/{mode}/v1/sessions/{sessionUUID}`
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)))
                .replace(`{${"sessionUUID"}}`, encodeURIComponent(String(sessionUUID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the settings of an active browser session. Currently supports extending the lease time.
         * @summary UpdateSession
         * @param {string} mode 
         * @param {string} sessionUUID 
         * @param {UpdateSessionRequestBody} updateSessionRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1SessionsSessionUUIDPatch: async (mode: string, sessionUUID: string, updateSessionRequestBody: UpdateSessionRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mode' is not null or undefined
            assertParamExists('modeV1SessionsSessionUUIDPatch', 'mode', mode)
            // verify required parameter 'sessionUUID' is not null or undefined
            assertParamExists('modeV1SessionsSessionUUIDPatch', 'sessionUUID', sessionUUID)
            // verify required parameter 'updateSessionRequestBody' is not null or undefined
            assertParamExists('modeV1SessionsSessionUUIDPatch', 'updateSessionRequestBody', updateSessionRequestBody)
            const localVarPath = `/{mode}/v1/sessions/{sessionUUID}`
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)))
                .replace(`{${"sessionUUID"}}`, encodeURIComponent(String(sessionUUID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSessionRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SessionsApi - functional programming interface
 * @export
 */
export const SessionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SessionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Download file from session
         * @param {string} mode 
         * @param {string} sessionUUID 
         * @param {DownloadFileRequestBody} downloadFileRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modeV1SessionSessionUUIDDownloadFilePost(mode: string, sessionUUID: string, downloadFileRequestBody: DownloadFileRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileDownloadResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modeV1SessionSessionUUIDDownloadFilePost(mode, sessionUUID, downloadFileRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionsApi.modeV1SessionSessionUUIDDownloadFilePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get list of session files
         * @param {string} mode 
         * @param {string} sessionUUID 
         * @param {ModeV1SessionSessionUUIDFilesGetTypeEnum} type Type of files to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modeV1SessionSessionUUIDFilesGet(mode: string, sessionUUID: string, type: ModeV1SessionSessionUUIDFilesGetTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FilesListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modeV1SessionSessionUUIDFilesGet(mode, sessionUUID, type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionsApi.modeV1SessionSessionUUIDFilesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Upload file to session
         * @param {string} mode 
         * @param {string} sessionUUID 
         * @param {UploadFileRequestBody} uploadFileRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modeV1SessionSessionUUIDUploadFilePost(mode: string, sessionUUID: string, uploadFileRequestBody: UploadFileRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileUploadResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modeV1SessionSessionUUIDUploadFilePost(mode, sessionUUID, uploadFileRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionsApi.modeV1SessionSessionUUIDUploadFilePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Grant control to VNC client
         * @param {string} mode 
         * @param {string} sessionUUID 
         * @param {string} clientId 
         * @param {VncClientControlRequestBody} vncClientControlRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modeV1SessionSessionUUIDVncClientsClientIdGrantControlPost(mode: string, sessionUUID: string, clientId: string, vncClientControlRequestBody: VncClientControlRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modeV1SessionSessionUUIDVncClientsClientIdGrantControlPost(mode, sessionUUID, clientId, vncClientControlRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionsApi.modeV1SessionSessionUUIDVncClientsClientIdGrantControlPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove control from VNC client
         * @param {string} mode 
         * @param {string} sessionUUID 
         * @param {string} clientId 
         * @param {VncClientControlRequestBody} vncClientControlRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modeV1SessionSessionUUIDVncClientsClientIdRemoveControlDelete(mode: string, sessionUUID: string, clientId: string, vncClientControlRequestBody: VncClientControlRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modeV1SessionSessionUUIDVncClientsClientIdRemoveControlDelete(mode, sessionUUID, clientId, vncClientControlRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionsApi.modeV1SessionSessionUUIDVncClientsClientIdRemoveControlDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get list of VNC clients
         * @param {string} mode 
         * @param {string} sessionUUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modeV1SessionSessionUUIDVncClientsGet(mode: string, sessionUUID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VncClientsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modeV1SessionSessionUUIDVncClientsGet(mode, sessionUUID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionsApi.modeV1SessionSessionUUIDVncClientsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Register VNC API key
         * @param {string} mode 
         * @param {string} sessionUUID 
         * @param {RegisterApiKeyRequestBody} registerApiKeyRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modeV1SessionSessionUUIDVncRegisterApiKeyPost(mode: string, sessionUUID: string, registerApiKeyRequestBody: RegisterApiKeyRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modeV1SessionSessionUUIDVncRegisterApiKeyPost(mode, sessionUUID, registerApiKeyRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionsApi.modeV1SessionSessionUUIDVncRegisterApiKeyPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of all active browser sessions in your environment, including their status, VNC settings, and lease times.
         * @summary ListSessions
         * @param {string} mode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modeV1SessionsGet(mode: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModeV1SessionsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modeV1SessionsGet(mode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionsApi.modeV1SessionsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new browser session using a specified fingerprint (OPTIONAL). Configure VNC access, lease time, and other session parameters.
         * @summary CreateSessionWithoutFingerprint
         * @param {string} mode 
         * @param {CreateSessionRequestBody} createSessionRequestBody 
         * @param {string} [xFingerprintSecret] 
         * @param {string} [xEnvironmentId] 
         * @param {string} [xEnvironmentSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modeV1SessionsPost(mode: string, createSessionRequestBody: CreateSessionRequestBody, xFingerprintSecret?: string, xEnvironmentId?: string, xEnvironmentSecret?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Session>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modeV1SessionsPost(mode, createSessionRequestBody, xFingerprintSecret, xEnvironmentId, xEnvironmentSecret, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionsApi.modeV1SessionsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Terminates a browser session immediately, releasing all associated resources and ending the lease.
         * @summary EndSession
         * @param {string} mode 
         * @param {string} sessionUUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modeV1SessionsSessionUUIDDelete(mode: string, sessionUUID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modeV1SessionsSessionUUIDDelete(mode, sessionUUID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionsApi.modeV1SessionsSessionUUIDDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves detailed information about a specific browser session, including its status, settings, and remaining lease time.
         * @summary GetSession
         * @param {string} mode 
         * @param {string} sessionUUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modeV1SessionsSessionUUIDGet(mode: string, sessionUUID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Session>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modeV1SessionsSessionUUIDGet(mode, sessionUUID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionsApi.modeV1SessionsSessionUUIDGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the settings of an active browser session. Currently supports extending the lease time.
         * @summary UpdateSession
         * @param {string} mode 
         * @param {string} sessionUUID 
         * @param {UpdateSessionRequestBody} updateSessionRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modeV1SessionsSessionUUIDPatch(mode: string, sessionUUID: string, updateSessionRequestBody: UpdateSessionRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modeV1SessionsSessionUUIDPatch(mode, sessionUUID, updateSessionRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionsApi.modeV1SessionsSessionUUIDPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SessionsApi - factory interface
 * @export
 */
export const SessionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SessionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Download file from session
         * @param {string} mode 
         * @param {string} sessionUUID 
         * @param {DownloadFileRequestBody} downloadFileRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1SessionSessionUUIDDownloadFilePost(mode: string, sessionUUID: string, downloadFileRequestBody: DownloadFileRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<FileDownloadResponse> {
            return localVarFp.modeV1SessionSessionUUIDDownloadFilePost(mode, sessionUUID, downloadFileRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get list of session files
         * @param {string} mode 
         * @param {string} sessionUUID 
         * @param {ModeV1SessionSessionUUIDFilesGetTypeEnum} type Type of files to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1SessionSessionUUIDFilesGet(mode: string, sessionUUID: string, type: ModeV1SessionSessionUUIDFilesGetTypeEnum, options?: RawAxiosRequestConfig): AxiosPromise<FilesListResponse> {
            return localVarFp.modeV1SessionSessionUUIDFilesGet(mode, sessionUUID, type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload file to session
         * @param {string} mode 
         * @param {string} sessionUUID 
         * @param {UploadFileRequestBody} uploadFileRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1SessionSessionUUIDUploadFilePost(mode: string, sessionUUID: string, uploadFileRequestBody: UploadFileRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<FileUploadResponse> {
            return localVarFp.modeV1SessionSessionUUIDUploadFilePost(mode, sessionUUID, uploadFileRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Grant control to VNC client
         * @param {string} mode 
         * @param {string} sessionUUID 
         * @param {string} clientId 
         * @param {VncClientControlRequestBody} vncClientControlRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1SessionSessionUUIDVncClientsClientIdGrantControlPost(mode: string, sessionUUID: string, clientId: string, vncClientControlRequestBody: VncClientControlRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.modeV1SessionSessionUUIDVncClientsClientIdGrantControlPost(mode, sessionUUID, clientId, vncClientControlRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove control from VNC client
         * @param {string} mode 
         * @param {string} sessionUUID 
         * @param {string} clientId 
         * @param {VncClientControlRequestBody} vncClientControlRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1SessionSessionUUIDVncClientsClientIdRemoveControlDelete(mode: string, sessionUUID: string, clientId: string, vncClientControlRequestBody: VncClientControlRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.modeV1SessionSessionUUIDVncClientsClientIdRemoveControlDelete(mode, sessionUUID, clientId, vncClientControlRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get list of VNC clients
         * @param {string} mode 
         * @param {string} sessionUUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1SessionSessionUUIDVncClientsGet(mode: string, sessionUUID: string, options?: RawAxiosRequestConfig): AxiosPromise<VncClientsResponse> {
            return localVarFp.modeV1SessionSessionUUIDVncClientsGet(mode, sessionUUID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register VNC API key
         * @param {string} mode 
         * @param {string} sessionUUID 
         * @param {RegisterApiKeyRequestBody} registerApiKeyRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1SessionSessionUUIDVncRegisterApiKeyPost(mode: string, sessionUUID: string, registerApiKeyRequestBody: RegisterApiKeyRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.modeV1SessionSessionUUIDVncRegisterApiKeyPost(mode, sessionUUID, registerApiKeyRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of all active browser sessions in your environment, including their status, VNC settings, and lease times.
         * @summary ListSessions
         * @param {string} mode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1SessionsGet(mode: string, options?: RawAxiosRequestConfig): AxiosPromise<ModeV1SessionsGet200Response> {
            return localVarFp.modeV1SessionsGet(mode, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new browser session using a specified fingerprint (OPTIONAL). Configure VNC access, lease time, and other session parameters.
         * @summary CreateSessionWithoutFingerprint
         * @param {string} mode 
         * @param {CreateSessionRequestBody} createSessionRequestBody 
         * @param {string} [xFingerprintSecret] 
         * @param {string} [xEnvironmentId] 
         * @param {string} [xEnvironmentSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1SessionsPost(mode: string, createSessionRequestBody: CreateSessionRequestBody, xFingerprintSecret?: string, xEnvironmentId?: string, xEnvironmentSecret?: string, options?: RawAxiosRequestConfig): AxiosPromise<Session> {
            return localVarFp.modeV1SessionsPost(mode, createSessionRequestBody, xFingerprintSecret, xEnvironmentId, xEnvironmentSecret, options).then((request) => request(axios, basePath));
        },
        /**
         * Terminates a browser session immediately, releasing all associated resources and ending the lease.
         * @summary EndSession
         * @param {string} mode 
         * @param {string} sessionUUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1SessionsSessionUUIDDelete(mode: string, sessionUUID: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.modeV1SessionsSessionUUIDDelete(mode, sessionUUID, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves detailed information about a specific browser session, including its status, settings, and remaining lease time.
         * @summary GetSession
         * @param {string} mode 
         * @param {string} sessionUUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1SessionsSessionUUIDGet(mode: string, sessionUUID: string, options?: RawAxiosRequestConfig): AxiosPromise<Session> {
            return localVarFp.modeV1SessionsSessionUUIDGet(mode, sessionUUID, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the settings of an active browser session. Currently supports extending the lease time.
         * @summary UpdateSession
         * @param {string} mode 
         * @param {string} sessionUUID 
         * @param {UpdateSessionRequestBody} updateSessionRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1SessionsSessionUUIDPatch(mode: string, sessionUUID: string, updateSessionRequestBody: UpdateSessionRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.modeV1SessionsSessionUUIDPatch(mode, sessionUUID, updateSessionRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SessionsApi - object-oriented interface
 * @export
 * @class SessionsApi
 * @extends {BaseAPI}
 */
export class SessionsApi extends BaseAPI {
    /**
     * 
     * @summary Download file from session
     * @param {string} mode 
     * @param {string} sessionUUID 
     * @param {DownloadFileRequestBody} downloadFileRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public modeV1SessionSessionUUIDDownloadFilePost(mode: string, sessionUUID: string, downloadFileRequestBody: DownloadFileRequestBody, options?: RawAxiosRequestConfig) {
        return SessionsApiFp(this.configuration).modeV1SessionSessionUUIDDownloadFilePost(mode, sessionUUID, downloadFileRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get list of session files
     * @param {string} mode 
     * @param {string} sessionUUID 
     * @param {ModeV1SessionSessionUUIDFilesGetTypeEnum} type Type of files to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public modeV1SessionSessionUUIDFilesGet(mode: string, sessionUUID: string, type: ModeV1SessionSessionUUIDFilesGetTypeEnum, options?: RawAxiosRequestConfig) {
        return SessionsApiFp(this.configuration).modeV1SessionSessionUUIDFilesGet(mode, sessionUUID, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload file to session
     * @param {string} mode 
     * @param {string} sessionUUID 
     * @param {UploadFileRequestBody} uploadFileRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public modeV1SessionSessionUUIDUploadFilePost(mode: string, sessionUUID: string, uploadFileRequestBody: UploadFileRequestBody, options?: RawAxiosRequestConfig) {
        return SessionsApiFp(this.configuration).modeV1SessionSessionUUIDUploadFilePost(mode, sessionUUID, uploadFileRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Grant control to VNC client
     * @param {string} mode 
     * @param {string} sessionUUID 
     * @param {string} clientId 
     * @param {VncClientControlRequestBody} vncClientControlRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public modeV1SessionSessionUUIDVncClientsClientIdGrantControlPost(mode: string, sessionUUID: string, clientId: string, vncClientControlRequestBody: VncClientControlRequestBody, options?: RawAxiosRequestConfig) {
        return SessionsApiFp(this.configuration).modeV1SessionSessionUUIDVncClientsClientIdGrantControlPost(mode, sessionUUID, clientId, vncClientControlRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove control from VNC client
     * @param {string} mode 
     * @param {string} sessionUUID 
     * @param {string} clientId 
     * @param {VncClientControlRequestBody} vncClientControlRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public modeV1SessionSessionUUIDVncClientsClientIdRemoveControlDelete(mode: string, sessionUUID: string, clientId: string, vncClientControlRequestBody: VncClientControlRequestBody, options?: RawAxiosRequestConfig) {
        return SessionsApiFp(this.configuration).modeV1SessionSessionUUIDVncClientsClientIdRemoveControlDelete(mode, sessionUUID, clientId, vncClientControlRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get list of VNC clients
     * @param {string} mode 
     * @param {string} sessionUUID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public modeV1SessionSessionUUIDVncClientsGet(mode: string, sessionUUID: string, options?: RawAxiosRequestConfig) {
        return SessionsApiFp(this.configuration).modeV1SessionSessionUUIDVncClientsGet(mode, sessionUUID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register VNC API key
     * @param {string} mode 
     * @param {string} sessionUUID 
     * @param {RegisterApiKeyRequestBody} registerApiKeyRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public modeV1SessionSessionUUIDVncRegisterApiKeyPost(mode: string, sessionUUID: string, registerApiKeyRequestBody: RegisterApiKeyRequestBody, options?: RawAxiosRequestConfig) {
        return SessionsApiFp(this.configuration).modeV1SessionSessionUUIDVncRegisterApiKeyPost(mode, sessionUUID, registerApiKeyRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of all active browser sessions in your environment, including their status, VNC settings, and lease times.
     * @summary ListSessions
     * @param {string} mode 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public modeV1SessionsGet(mode: string, options?: RawAxiosRequestConfig) {
        return SessionsApiFp(this.configuration).modeV1SessionsGet(mode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new browser session using a specified fingerprint (OPTIONAL). Configure VNC access, lease time, and other session parameters.
     * @summary CreateSessionWithoutFingerprint
     * @param {string} mode 
     * @param {CreateSessionRequestBody} createSessionRequestBody 
     * @param {string} [xFingerprintSecret] 
     * @param {string} [xEnvironmentId] 
     * @param {string} [xEnvironmentSecret] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public modeV1SessionsPost(mode: string, createSessionRequestBody: CreateSessionRequestBody, xFingerprintSecret?: string, xEnvironmentId?: string, xEnvironmentSecret?: string, options?: RawAxiosRequestConfig) {
        return SessionsApiFp(this.configuration).modeV1SessionsPost(mode, createSessionRequestBody, xFingerprintSecret, xEnvironmentId, xEnvironmentSecret, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Terminates a browser session immediately, releasing all associated resources and ending the lease.
     * @summary EndSession
     * @param {string} mode 
     * @param {string} sessionUUID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public modeV1SessionsSessionUUIDDelete(mode: string, sessionUUID: string, options?: RawAxiosRequestConfig) {
        return SessionsApiFp(this.configuration).modeV1SessionsSessionUUIDDelete(mode, sessionUUID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves detailed information about a specific browser session, including its status, settings, and remaining lease time.
     * @summary GetSession
     * @param {string} mode 
     * @param {string} sessionUUID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public modeV1SessionsSessionUUIDGet(mode: string, sessionUUID: string, options?: RawAxiosRequestConfig) {
        return SessionsApiFp(this.configuration).modeV1SessionsSessionUUIDGet(mode, sessionUUID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the settings of an active browser session. Currently supports extending the lease time.
     * @summary UpdateSession
     * @param {string} mode 
     * @param {string} sessionUUID 
     * @param {UpdateSessionRequestBody} updateSessionRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public modeV1SessionsSessionUUIDPatch(mode: string, sessionUUID: string, updateSessionRequestBody: UpdateSessionRequestBody, options?: RawAxiosRequestConfig) {
        return SessionsApiFp(this.configuration).modeV1SessionsSessionUUIDPatch(mode, sessionUUID, updateSessionRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ModeV1SessionSessionUUIDFilesGetTypeEnum = {
    Upload: 'upload',
    Download: 'download'
} as const;
export type ModeV1SessionSessionUUIDFilesGetTypeEnum = typeof ModeV1SessionSessionUUIDFilesGetTypeEnum[keyof typeof ModeV1SessionSessionUUIDFilesGetTypeEnum];


