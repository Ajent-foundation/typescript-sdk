/* tslint:disable */
/* eslint-disable */
/**
 * tasknet-api
 * This Browser API (v1) provides a comprehensive suite of endpoints for managing automated browser sessions and browser fingerprinting, enabling users to create and control browser instances with customizable configurations. The API supports sophisticated fingerprinting capabilities for specifying browser characteristics (including screen properties, device capabilities, and proxy settings), session management features for controlling browser instances (with VNC connectivity options and lease time management), extension management for enhancing browser functionality, and page control operations for automated browsing.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: ajoor@tasker.ai
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * Type of browser used for fingerprinting
 * @export
 * @enum {string}
 */

export const BrowserType = {
    Chromium: 'chromium'
} as const;

export type BrowserType = typeof BrowserType[keyof typeof BrowserType];


/**
 * 
 * @export
 * @interface CreateFingerprintRequestBody
 */
export interface CreateFingerprintRequestBody {
    /**
     * 
     * @type {string}
     * @memberof CreateFingerprintRequestBody
     */
    'environmentUUID': string;
    /**
     * 
     * @type {CreateFingerprintRequestBodyScreen}
     * @memberof CreateFingerprintRequestBody
     */
    'screen': CreateFingerprintRequestBodyScreen;
    /**
     * 
     * @type {CreateFingerprintRequestBodyDevice}
     * @memberof CreateFingerprintRequestBody
     */
    'device'?: CreateFingerprintRequestBodyDevice;
    /**
     * 
     * @type {CreateFingerprintRequestBodyProxy}
     * @memberof CreateFingerprintRequestBody
     */
    'proxy'?: CreateFingerprintRequestBodyProxy;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateFingerprintRequestBody
     */
    'extensions'?: Array<string>;
}
/**
 * 
 * @export
 * @interface CreateFingerprintRequestBodyDevice
 */
export interface CreateFingerprintRequestBodyDevice {
    /**
     * 
     * @type {number}
     * @memberof CreateFingerprintRequestBodyDevice
     */
    'numSpeakers'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateFingerprintRequestBodyDevice
     */
    'numMicrophones'?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateFingerprintRequestBodyDevice
     */
    'numCameras'?: number;
}
/**
 * 
 * @export
 * @interface CreateFingerprintRequestBodyProxy
 */
export interface CreateFingerprintRequestBodyProxy {
    /**
     * 
     * @type {string}
     * @memberof CreateFingerprintRequestBodyProxy
     */
    'country'?: string;
}
/**
 * 
 * @export
 * @interface CreateFingerprintRequestBodyScreen
 */
export interface CreateFingerprintRequestBodyScreen {
    /**
     * 
     * @type {ScreenResolution}
     * @memberof CreateFingerprintRequestBodyScreen
     */
    'resolution': ScreenResolution;
    /**
     * 
     * @type {ScreenDepth}
     * @memberof CreateFingerprintRequestBodyScreen
     */
    'depth': ScreenDepth;
    /**
     * 
     * @type {ScreenDPI}
     * @memberof CreateFingerprintRequestBodyScreen
     */
    'dpi': ScreenDPI;
}


/**
 * 
 * @export
 * @interface CreateRandomFingerprintRequest
 */
export interface CreateRandomFingerprintRequest {
    /**
     * UUID of the environment to create the fingerprint in
     * @type {string}
     * @memberof CreateRandomFingerprintRequest
     */
    'environmentUUID': string;
}
/**
 * 
 * @export
 * @interface CreateSessionRequestBody
 */
export interface CreateSessionRequestBody {
    /**
     * 
     * @type {string}
     * @memberof CreateSessionRequestBody
     */
    'fingerprintUUID'?: string;
    /**
     * Duration of the session lease in minutes
     * @type {number}
     * @memberof CreateSessionRequestBody
     */
    'leaseTime': number;
    /**
     * Whether VNC access is enabled for this session
     * @type {boolean}
     * @memberof CreateSessionRequestBody
     */
    'isVncEnabled': boolean;
    /**
     * 
     * @type {VncMode}
     * @memberof CreateSessionRequestBody
     */
    'vncMode': VncMode;
    /**
     * 
     * @type {DriverType}
     * @memberof CreateSessionRequestBody
     */
    'driver': DriverType;
    /**
     * Whether to show mouse movements
     * @type {boolean}
     * @memberof CreateSessionRequestBody
     */
    'showMouse'?: boolean;
    /**
     * Whether to enable proxy for this session
     * @type {boolean}
     * @memberof CreateSessionRequestBody
     */
    'isProxyEnabled'?: boolean;
}


/**
 * Type of device being emulated
 * @export
 * @enum {string}
 */

export const DeviceType = {
    Desktop: 'desktop',
    Mobile: 'mobile',
    Tablet: 'tablet'
} as const;

export type DeviceType = typeof DeviceType[keyof typeof DeviceType];


/**
 * Browser automation driver type
 * @export
 * @enum {string}
 */

export const DriverType = {
    Puppeteer: 'puppeteer',
    Api: 'api'
} as const;

export type DriverType = typeof DriverType[keyof typeof DriverType];


/**
 * 
 * @export
 * @interface Extension
 */
export interface Extension {
    /**
     * Brief description of the extension\'s functionality
     * @type {string}
     * @memberof Extension
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof Extension
     */
    'extensionUUID': string;
    /**
     * 
     * @type {string}
     * @memberof Extension
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Extension
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface Fingerprint
 */
export interface Fingerprint {
    /**
     * 
     * @type {string}
     * @memberof Fingerprint
     */
    'fingerprintUUID': string;
    /**
     * 
     * @type {boolean}
     * @memberof Fingerprint
     */
    'isArchived': boolean;
    /**
     * 
     * @type {FingerprintBrowserConfig}
     * @memberof Fingerprint
     */
    'browserConfig': FingerprintBrowserConfig;
    /**
     * 
     * @type {FingerprintProxy}
     * @memberof Fingerprint
     */
    'proxy': FingerprintProxy;
    /**
     * 
     * @type {string}
     * @memberof Fingerprint
     */
    'language': string;
    /**
     * 
     * @type {string}
     * @memberof Fingerprint
     */
    'timeZone': string;
    /**
     * 
     * @type {Platform}
     * @memberof Fingerprint
     */
    'platform': Platform;
    /**
     * 
     * @type {DeviceType}
     * @memberof Fingerprint
     */
    'deviceType': DeviceType;
    /**
     * 
     * @type {string}
     * @memberof Fingerprint
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Fingerprint
     */
    'updatedAt': string;
}


/**
 * 
 * @export
 * @interface FingerprintBrowserConfig
 */
export interface FingerprintBrowserConfig {
    /**
     * 
     * @type {BrowserType}
     * @memberof FingerprintBrowserConfig
     */
    'browser': BrowserType;
    /**
     * 
     * @type {Array<string>}
     * @memberof FingerprintBrowserConfig
     */
    'extensions': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof FingerprintBrowserConfig
     */
    'numCameras': number;
    /**
     * 
     * @type {number}
     * @memberof FingerprintBrowserConfig
     */
    'numMicrophones': number;
    /**
     * 
     * @type {number}
     * @memberof FingerprintBrowserConfig
     */
    'numSpeakers': number;
    /**
     * 
     * @type {ScreenDPI}
     * @memberof FingerprintBrowserConfig
     */
    'screenDPI': ScreenDPI;
    /**
     * 
     * @type {ScreenDepth}
     * @memberof FingerprintBrowserConfig
     */
    'screenDepth': ScreenDepth;
    /**
     * 
     * @type {ScreenResolution}
     * @memberof FingerprintBrowserConfig
     */
    'screenResolution': ScreenResolution;
}


/**
 * 
 * @export
 * @interface FingerprintProxy
 */
export interface FingerprintProxy {
    /**
     * 
     * @type {Array<string>}
     * @memberof FingerprintProxy
     */
    'appliedDomains': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof FingerprintProxy
     */
    'city': string;
    /**
     * 
     * @type {string}
     * @memberof FingerprintProxy
     */
    'country': string;
    /**
     * 
     * @type {string}
     * @memberof FingerprintProxy
     */
    'state': string;
    /**
     * 
     * @type {ProxyType}
     * @memberof FingerprintProxy
     */
    'type': ProxyType;
}


/**
 * 
 * @export
 * @interface FingerprintWithSecret
 */
export interface FingerprintWithSecret {
    /**
     * 
     * @type {string}
     * @memberof FingerprintWithSecret
     */
    'fingerprintUUID': string;
    /**
     * 
     * @type {boolean}
     * @memberof FingerprintWithSecret
     */
    'isArchived': boolean;
    /**
     * 
     * @type {FingerprintBrowserConfig}
     * @memberof FingerprintWithSecret
     */
    'browserConfig': FingerprintBrowserConfig;
    /**
     * 
     * @type {FingerprintProxy}
     * @memberof FingerprintWithSecret
     */
    'proxy': FingerprintProxy;
    /**
     * 
     * @type {string}
     * @memberof FingerprintWithSecret
     */
    'language': string;
    /**
     * 
     * @type {string}
     * @memberof FingerprintWithSecret
     */
    'timeZone': string;
    /**
     * 
     * @type {Platform}
     * @memberof FingerprintWithSecret
     */
    'platform': Platform;
    /**
     * 
     * @type {DeviceType}
     * @memberof FingerprintWithSecret
     */
    'deviceType': DeviceType;
    /**
     * 
     * @type {string}
     * @memberof FingerprintWithSecret
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof FingerprintWithSecret
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof FingerprintWithSecret
     */
    'fingerprintSecret'?: string;
}


/**
 * 
 * @export
 * @interface ModeV1ExtensionsGet200Response
 */
export interface ModeV1ExtensionsGet200Response {
    /**
     * 
     * @type {Array<Extension>}
     * @memberof ModeV1ExtensionsGet200Response
     */
    'extensions'?: Array<Extension>;
}
/**
 * 
 * @export
 * @interface ModeV1FingerprintsGet200Response
 */
export interface ModeV1FingerprintsGet200Response {
    /**
     * 
     * @type {Array<Fingerprint>}
     * @memberof ModeV1FingerprintsGet200Response
     */
    'fingerprints'?: Array<Fingerprint>;
    /**
     * 
     * @type {number}
     * @memberof ModeV1FingerprintsGet200Response
     */
    'prevPage'?: number;
    /**
     * 
     * @type {number}
     * @memberof ModeV1FingerprintsGet200Response
     */
    'nextPage'?: number;
    /**
     * 
     * @type {number}
     * @memberof ModeV1FingerprintsGet200Response
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface ModeV1PageExecuteCommandsPostRequest
 */
export interface ModeV1PageExecuteCommandsPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ModeV1PageExecuteCommandsPostRequest
     */
    'sessionUUID': string;
    /**
     * 
     * @type {Array<object>}
     * @memberof ModeV1PageExecuteCommandsPostRequest
     */
    'commands': Array<object>;
}
/**
 * 
 * @export
 * @interface ModeV1PageGoToPagePostRequest
 */
export interface ModeV1PageGoToPagePostRequest {
    /**
     * 
     * @type {string}
     * @memberof ModeV1PageGoToPagePostRequest
     */
    'sessionUUID': string;
    /**
     * 
     * @type {string}
     * @memberof ModeV1PageGoToPagePostRequest
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface ModeV1SessionsGet200Response
 */
export interface ModeV1SessionsGet200Response {
    /**
     * 
     * @type {Array<Session>}
     * @memberof ModeV1SessionsGet200Response
     */
    'sessions'?: Array<Session>;
}
/**
 * 
 * @export
 * @interface Operator
 */
export interface Operator {
    /**
     * 
     * @type {number}
     * @memberof Operator
     */
    'numOfBrowsers': number;
    /**
     * 
     * @type {OperatorInfo}
     * @memberof Operator
     */
    'info': OperatorInfo;
    /**
     * 
     * @type {string}
     * @memberof Operator
     */
    'connectedAt': string;
    /**
     * 
     * @type {string}
     * @memberof Operator
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface OperatorInfo
 */
export interface OperatorInfo {
    /**
     * 
     * @type {string}
     * @memberof OperatorInfo
     */
    'platform': string;
    /**
     * 
     * @type {string}
     * @memberof OperatorInfo
     */
    'architecture': string;
    /**
     * 
     * @type {number}
     * @memberof OperatorInfo
     */
    'freeMemory': number;
    /**
     * 
     * @type {number}
     * @memberof OperatorInfo
     */
    'totalMemory': number;
    /**
     * 
     * @type {string}
     * @memberof OperatorInfo
     */
    'cpuModel': string;
    /**
     * 
     * @type {string}
     * @memberof OperatorInfo
     */
    'hostname': string;
}
/**
 * Operating system platform
 * @export
 * @enum {string}
 */

export const Platform = {
    Windows: 'Windows',
    MacOs: 'MacOS',
    Linux: 'Linux',
    Android: 'Android',
    IOs: 'iOS'
} as const;

export type Platform = typeof Platform[keyof typeof Platform];


/**
 * Type of proxy connection
 * @export
 * @enum {string}
 */

export const ProxyType = {
    Residential: 'residential'
} as const;

export type ProxyType = typeof ProxyType[keyof typeof ProxyType];


/**
 * Valid DPI (Dots Per Inch) values for screen configuration Possible values: 96, 120, 144, 192 
 * @export
 * @enum {number}
 */

export const ScreenDPI = {
    NUMBER_96: 96,
    NUMBER_120: 120,
    NUMBER_144: 144,
    NUMBER_192: 192
} as const;

export type ScreenDPI = typeof ScreenDPI[keyof typeof ScreenDPI];


/**
 * Valid color depth values for screen configuration Possible values: 24, 30, 32 
 * @export
 * @enum {number}
 */

export const ScreenDepth = {
    NUMBER_24: 24,
    NUMBER_30: 30,
    NUMBER_32: 32
} as const;

export type ScreenDepth = typeof ScreenDepth[keyof typeof ScreenDepth];


/**
 * Valid screen resolution values Common display resolutions in \"widthxheight\" format 
 * @export
 * @enum {string}
 */

export const ScreenResolution = {
    _1280x1024: '1280x1024',
    _1920x1080: '1920x1080',
    _1366x768: '1366x768',
    _1536x864: '1536x864',
    _1280x720: '1280x720',
    _1440x900: '1440x900',
    _1280x2400: '1280x2400'
} as const;

export type ScreenResolution = typeof ScreenResolution[keyof typeof ScreenResolution];


/**
 * 
 * @export
 * @interface Session
 */
export interface Session {
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'sessionUUID': string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'fingerprintUUID': string;
    /**
     * 
     * @type {number}
     * @memberof Session
     */
    'currentLeaseTime': number;
    /**
     * 
     * @type {boolean}
     * @memberof Session
     */
    'isVncEnabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'updatedAt': string;
    /**
     * 
     * @type {DriverType}
     * @memberof Session
     */
    'driver': DriverType;
    /**
     * 
     * @type {SessionStatus}
     * @memberof Session
     */
    'status': SessionStatus;
    /**
     * 
     * @type {VncMode}
     * @memberof Session
     */
    'vncMode': VncMode;
}


/**
 * The status of the session
 * @export
 * @enum {string}
 */

export const SessionStatus = {
    Running: 'running',
    Terminated: 'terminated'
} as const;

export type SessionStatus = typeof SessionStatus[keyof typeof SessionStatus];


/**
 * 
 * @export
 * @interface UpdateFingerprintProxyRequest
 */
export interface UpdateFingerprintProxyRequest {
    /**
     * Two-letter ISO country code for proxy location
     * @type {string}
     * @memberof UpdateFingerprintProxyRequest
     */
    'country': string;
}
/**
 * 
 * @export
 * @interface UpdateSessionRequestBody
 */
export interface UpdateSessionRequestBody {
    /**
     * 
     * @type {number}
     * @memberof UpdateSessionRequestBody
     */
    'newLeaseTime': number;
}
/**
 * 
 * @export
 * @interface V1OperatorsInfoGet200Response
 */
export interface V1OperatorsInfoGet200Response {
    /**
     * 
     * @type {Array<Operator>}
     * @memberof V1OperatorsInfoGet200Response
     */
    'nodes': Array<Operator>;
    /**
     * 
     * @type {number}
     * @memberof V1OperatorsInfoGet200Response
     */
    'browsers': number;
}
/**
 * 
 * @export
 * @interface V1OperatorsListAllGet200Response
 */
export interface V1OperatorsListAllGet200Response {
    /**
     * 
     * @type {Array<Operator>}
     * @memberof V1OperatorsListAllGet200Response
     */
    'nodes': Array<Operator>;
}
/**
 * 
 * @export
 * @interface V1OperatorsRandomGet200Response
 */
export interface V1OperatorsRandomGet200Response {
    /**
     * 
     * @type {string}
     * @memberof V1OperatorsRandomGet200Response
     */
    'operatorId': string;
}
/**
 * VNC access mode (read-write or read-only)
 * @export
 * @enum {string}
 */

export const VncMode = {
    Rw: 'rw',
    Ro: 'ro'
} as const;

export type VncMode = typeof VncMode[keyof typeof VncMode];



/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary isRunning?
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rootGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary isRunning?
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rootGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rootGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.rootGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary isRunning?
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rootGet(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rootGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary isRunning?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public rootGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).rootGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ExtensionsApi - axios parameter creator
 * @export
 */
export const ExtensionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves detailed information about a specific browser extension, including its name, description, and installation URL.
         * @summary GetExtension
         * @param {string} mode 
         * @param {string} extensionUUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1ExtensionsExtensionUUIDGet: async (mode: string, extensionUUID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mode' is not null or undefined
            assertParamExists('modeV1ExtensionsExtensionUUIDGet', 'mode', mode)
            // verify required parameter 'extensionUUID' is not null or undefined
            assertParamExists('modeV1ExtensionsExtensionUUIDGet', 'extensionUUID', extensionUUID)
            const localVarPath = `/{mode}/v1/extensions/{extensionUUID}`
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)))
                .replace(`{${"extensionUUID"}}`, encodeURIComponent(String(extensionUUID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of all available browser extensions that can be added to fingerprints. These extensions can enhance browser functionality for specific use cases.
         * @summary ListExtensions
         * @param {string} mode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1ExtensionsGet: async (mode: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mode' is not null or undefined
            assertParamExists('modeV1ExtensionsGet', 'mode', mode)
            const localVarPath = `/{mode}/v1/extensions`
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExtensionsApi - functional programming interface
 * @export
 */
export const ExtensionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExtensionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves detailed information about a specific browser extension, including its name, description, and installation URL.
         * @summary GetExtension
         * @param {string} mode 
         * @param {string} extensionUUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modeV1ExtensionsExtensionUUIDGet(mode: string, extensionUUID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Extension>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modeV1ExtensionsExtensionUUIDGet(mode, extensionUUID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExtensionsApi.modeV1ExtensionsExtensionUUIDGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of all available browser extensions that can be added to fingerprints. These extensions can enhance browser functionality for specific use cases.
         * @summary ListExtensions
         * @param {string} mode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modeV1ExtensionsGet(mode: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModeV1ExtensionsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modeV1ExtensionsGet(mode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExtensionsApi.modeV1ExtensionsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ExtensionsApi - factory interface
 * @export
 */
export const ExtensionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExtensionsApiFp(configuration)
    return {
        /**
         * Retrieves detailed information about a specific browser extension, including its name, description, and installation URL.
         * @summary GetExtension
         * @param {string} mode 
         * @param {string} extensionUUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1ExtensionsExtensionUUIDGet(mode: string, extensionUUID: string, options?: RawAxiosRequestConfig): AxiosPromise<Extension> {
            return localVarFp.modeV1ExtensionsExtensionUUIDGet(mode, extensionUUID, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of all available browser extensions that can be added to fingerprints. These extensions can enhance browser functionality for specific use cases.
         * @summary ListExtensions
         * @param {string} mode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1ExtensionsGet(mode: string, options?: RawAxiosRequestConfig): AxiosPromise<ModeV1ExtensionsGet200Response> {
            return localVarFp.modeV1ExtensionsGet(mode, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExtensionsApi - object-oriented interface
 * @export
 * @class ExtensionsApi
 * @extends {BaseAPI}
 */
export class ExtensionsApi extends BaseAPI {
    /**
     * Retrieves detailed information about a specific browser extension, including its name, description, and installation URL.
     * @summary GetExtension
     * @param {string} mode 
     * @param {string} extensionUUID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtensionsApi
     */
    public modeV1ExtensionsExtensionUUIDGet(mode: string, extensionUUID: string, options?: RawAxiosRequestConfig) {
        return ExtensionsApiFp(this.configuration).modeV1ExtensionsExtensionUUIDGet(mode, extensionUUID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of all available browser extensions that can be added to fingerprints. These extensions can enhance browser functionality for specific use cases.
     * @summary ListExtensions
     * @param {string} mode 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtensionsApi
     */
    public modeV1ExtensionsGet(mode: string, options?: RawAxiosRequestConfig) {
        return ExtensionsApiFp(this.configuration).modeV1ExtensionsGet(mode, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FingerprintsApi - axios parameter creator
 * @export
 */
export const FingerprintsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Archives a fingerprint by deleting all associated session data and marking it as no longer usable. Once archived, the fingerprint cannot be used to create new sessions.
         * @summary ArchiveFingerprint
         * @param {string} mode 
         * @param {string} fingerprintUUID 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1FingerprintsFingerprintUUIDArchivePost: async (mode: string, fingerprintUUID: string, body?: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mode' is not null or undefined
            assertParamExists('modeV1FingerprintsFingerprintUUIDArchivePost', 'mode', mode)
            // verify required parameter 'fingerprintUUID' is not null or undefined
            assertParamExists('modeV1FingerprintsFingerprintUUIDArchivePost', 'fingerprintUUID', fingerprintUUID)
            const localVarPath = `/{mode}/v1/fingerprints/{fingerprintUUID}/archive`
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)))
                .replace(`{${"fingerprintUUID"}}`, encodeURIComponent(String(fingerprintUUID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a copy of an existing fingerprint\'s settings but generates new session data. This allows you to duplicate a successful configuration while maintaining unique session identifiers.
         * @summary CloneFingerprint
         * @param {string} mode 
         * @param {string} fingerprintUUID 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1FingerprintsFingerprintUUIDClonePost: async (mode: string, fingerprintUUID: string, body?: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mode' is not null or undefined
            assertParamExists('modeV1FingerprintsFingerprintUUIDClonePost', 'mode', mode)
            // verify required parameter 'fingerprintUUID' is not null or undefined
            assertParamExists('modeV1FingerprintsFingerprintUUIDClonePost', 'fingerprintUUID', fingerprintUUID)
            const localVarPath = `/{mode}/v1/fingerprints/{fingerprintUUID}/clone`
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)))
                .replace(`{${"fingerprintUUID"}}`, encodeURIComponent(String(fingerprintUUID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves detailed information about a specific fingerprint, including its configuration, proxy settings, and session status.
         * @summary GetFingerprint
         * @param {string} mode 
         * @param {string} fingerprintUUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1FingerprintsFingerprintUUIDGet: async (mode: string, fingerprintUUID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mode' is not null or undefined
            assertParamExists('modeV1FingerprintsFingerprintUUIDGet', 'mode', mode)
            // verify required parameter 'fingerprintUUID' is not null or undefined
            assertParamExists('modeV1FingerprintsFingerprintUUIDGet', 'fingerprintUUID', fingerprintUUID)
            const localVarPath = `/{mode}/v1/fingerprints/{fingerprintUUID}`
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)))
                .replace(`{${"fingerprintUUID"}}`, encodeURIComponent(String(fingerprintUUID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the proxy settings for a specific fingerprint. This allows you to change the geographic location and routing of browser traffic.
         * @summary UpdateFingerprintProxy
         * @param {string} mode 
         * @param {string} fingerprintUUID 
         * @param {UpdateFingerprintProxyRequest} updateFingerprintProxyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1FingerprintsFingerprintUUIDProxyPatch: async (mode: string, fingerprintUUID: string, updateFingerprintProxyRequest: UpdateFingerprintProxyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mode' is not null or undefined
            assertParamExists('modeV1FingerprintsFingerprintUUIDProxyPatch', 'mode', mode)
            // verify required parameter 'fingerprintUUID' is not null or undefined
            assertParamExists('modeV1FingerprintsFingerprintUUIDProxyPatch', 'fingerprintUUID', fingerprintUUID)
            // verify required parameter 'updateFingerprintProxyRequest' is not null or undefined
            assertParamExists('modeV1FingerprintsFingerprintUUIDProxyPatch', 'updateFingerprintProxyRequest', updateFingerprintProxyRequest)
            const localVarPath = `/{mode}/v1/fingerprints/{fingerprintUUID}/proxy`
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)))
                .replace(`{${"fingerprintUUID"}}`, encodeURIComponent(String(fingerprintUUID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateFingerprintProxyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes all session data associated with the fingerprint while preserving its configuration. This allows you to start fresh with the same fingerprint settings.
         * @summary ResetFingerprint
         * @param {string} mode 
         * @param {string} fingerprintUUID 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1FingerprintsFingerprintUUIDResetPost: async (mode: string, fingerprintUUID: string, body?: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mode' is not null or undefined
            assertParamExists('modeV1FingerprintsFingerprintUUIDResetPost', 'mode', mode)
            // verify required parameter 'fingerprintUUID' is not null or undefined
            assertParamExists('modeV1FingerprintsFingerprintUUIDResetPost', 'fingerprintUUID', fingerprintUUID)
            const localVarPath = `/{mode}/v1/fingerprints/{fingerprintUUID}/reset`
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)))
                .replace(`{${"fingerprintUUID"}}`, encodeURIComponent(String(fingerprintUUID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ListFingerprints
         * @param {string} mode 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1FingerprintsGet: async (mode: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mode' is not null or undefined
            assertParamExists('modeV1FingerprintsGet', 'mode', mode)
            const localVarPath = `/{mode}/v1/fingerprints`
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new fingerprint with specified browser configuration, device settings, and proxy settings. This fingerprint can be used to start new browser sessions.
         * @summary CreateFingerprint
         * @param {string} mode 
         * @param {CreateFingerprintRequestBody} createFingerprintRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1FingerprintsPost: async (mode: string, createFingerprintRequestBody: CreateFingerprintRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mode' is not null or undefined
            assertParamExists('modeV1FingerprintsPost', 'mode', mode)
            // verify required parameter 'createFingerprintRequestBody' is not null or undefined
            assertParamExists('modeV1FingerprintsPost', 'createFingerprintRequestBody', createFingerprintRequestBody)
            const localVarPath = `/{mode}/v1/fingerprints`
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createFingerprintRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates a new fingerprint with randomized browser configuration, device settings, and proxy settings.
         * @summary CreateRandomFingerprint
         * @param {string} mode 
         * @param {CreateRandomFingerprintRequest} createRandomFingerprintRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1FingerprintsRandomPost: async (mode: string, createRandomFingerprintRequest: CreateRandomFingerprintRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mode' is not null or undefined
            assertParamExists('modeV1FingerprintsRandomPost', 'mode', mode)
            // verify required parameter 'createRandomFingerprintRequest' is not null or undefined
            assertParamExists('modeV1FingerprintsRandomPost', 'createRandomFingerprintRequest', createRandomFingerprintRequest)
            const localVarPath = `/{mode}/v1/fingerprints/random`
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRandomFingerprintRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FingerprintsApi - functional programming interface
 * @export
 */
export const FingerprintsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FingerprintsApiAxiosParamCreator(configuration)
    return {
        /**
         * Archives a fingerprint by deleting all associated session data and marking it as no longer usable. Once archived, the fingerprint cannot be used to create new sessions.
         * @summary ArchiveFingerprint
         * @param {string} mode 
         * @param {string} fingerprintUUID 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modeV1FingerprintsFingerprintUUIDArchivePost(mode: string, fingerprintUUID: string, body?: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modeV1FingerprintsFingerprintUUIDArchivePost(mode, fingerprintUUID, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FingerprintsApi.modeV1FingerprintsFingerprintUUIDArchivePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a copy of an existing fingerprint\'s settings but generates new session data. This allows you to duplicate a successful configuration while maintaining unique session identifiers.
         * @summary CloneFingerprint
         * @param {string} mode 
         * @param {string} fingerprintUUID 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modeV1FingerprintsFingerprintUUIDClonePost(mode: string, fingerprintUUID: string, body?: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FingerprintWithSecret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modeV1FingerprintsFingerprintUUIDClonePost(mode, fingerprintUUID, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FingerprintsApi.modeV1FingerprintsFingerprintUUIDClonePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves detailed information about a specific fingerprint, including its configuration, proxy settings, and session status.
         * @summary GetFingerprint
         * @param {string} mode 
         * @param {string} fingerprintUUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modeV1FingerprintsFingerprintUUIDGet(mode: string, fingerprintUUID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Fingerprint>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modeV1FingerprintsFingerprintUUIDGet(mode, fingerprintUUID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FingerprintsApi.modeV1FingerprintsFingerprintUUIDGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the proxy settings for a specific fingerprint. This allows you to change the geographic location and routing of browser traffic.
         * @summary UpdateFingerprintProxy
         * @param {string} mode 
         * @param {string} fingerprintUUID 
         * @param {UpdateFingerprintProxyRequest} updateFingerprintProxyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modeV1FingerprintsFingerprintUUIDProxyPatch(mode: string, fingerprintUUID: string, updateFingerprintProxyRequest: UpdateFingerprintProxyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modeV1FingerprintsFingerprintUUIDProxyPatch(mode, fingerprintUUID, updateFingerprintProxyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FingerprintsApi.modeV1FingerprintsFingerprintUUIDProxyPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes all session data associated with the fingerprint while preserving its configuration. This allows you to start fresh with the same fingerprint settings.
         * @summary ResetFingerprint
         * @param {string} mode 
         * @param {string} fingerprintUUID 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modeV1FingerprintsFingerprintUUIDResetPost(mode: string, fingerprintUUID: string, body?: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modeV1FingerprintsFingerprintUUIDResetPost(mode, fingerprintUUID, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FingerprintsApi.modeV1FingerprintsFingerprintUUIDResetPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary ListFingerprints
         * @param {string} mode 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modeV1FingerprintsGet(mode: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModeV1FingerprintsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modeV1FingerprintsGet(mode, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FingerprintsApi.modeV1FingerprintsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new fingerprint with specified browser configuration, device settings, and proxy settings. This fingerprint can be used to start new browser sessions.
         * @summary CreateFingerprint
         * @param {string} mode 
         * @param {CreateFingerprintRequestBody} createFingerprintRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modeV1FingerprintsPost(mode: string, createFingerprintRequestBody: CreateFingerprintRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FingerprintWithSecret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modeV1FingerprintsPost(mode, createFingerprintRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FingerprintsApi.modeV1FingerprintsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generates a new fingerprint with randomized browser configuration, device settings, and proxy settings.
         * @summary CreateRandomFingerprint
         * @param {string} mode 
         * @param {CreateRandomFingerprintRequest} createRandomFingerprintRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modeV1FingerprintsRandomPost(mode: string, createRandomFingerprintRequest: CreateRandomFingerprintRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FingerprintWithSecret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modeV1FingerprintsRandomPost(mode, createRandomFingerprintRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FingerprintsApi.modeV1FingerprintsRandomPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FingerprintsApi - factory interface
 * @export
 */
export const FingerprintsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FingerprintsApiFp(configuration)
    return {
        /**
         * Archives a fingerprint by deleting all associated session data and marking it as no longer usable. Once archived, the fingerprint cannot be used to create new sessions.
         * @summary ArchiveFingerprint
         * @param {string} mode 
         * @param {string} fingerprintUUID 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1FingerprintsFingerprintUUIDArchivePost(mode: string, fingerprintUUID: string, body?: object, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.modeV1FingerprintsFingerprintUUIDArchivePost(mode, fingerprintUUID, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a copy of an existing fingerprint\'s settings but generates new session data. This allows you to duplicate a successful configuration while maintaining unique session identifiers.
         * @summary CloneFingerprint
         * @param {string} mode 
         * @param {string} fingerprintUUID 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1FingerprintsFingerprintUUIDClonePost(mode: string, fingerprintUUID: string, body?: object, options?: RawAxiosRequestConfig): AxiosPromise<FingerprintWithSecret> {
            return localVarFp.modeV1FingerprintsFingerprintUUIDClonePost(mode, fingerprintUUID, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves detailed information about a specific fingerprint, including its configuration, proxy settings, and session status.
         * @summary GetFingerprint
         * @param {string} mode 
         * @param {string} fingerprintUUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1FingerprintsFingerprintUUIDGet(mode: string, fingerprintUUID: string, options?: RawAxiosRequestConfig): AxiosPromise<Fingerprint> {
            return localVarFp.modeV1FingerprintsFingerprintUUIDGet(mode, fingerprintUUID, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the proxy settings for a specific fingerprint. This allows you to change the geographic location and routing of browser traffic.
         * @summary UpdateFingerprintProxy
         * @param {string} mode 
         * @param {string} fingerprintUUID 
         * @param {UpdateFingerprintProxyRequest} updateFingerprintProxyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1FingerprintsFingerprintUUIDProxyPatch(mode: string, fingerprintUUID: string, updateFingerprintProxyRequest: UpdateFingerprintProxyRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.modeV1FingerprintsFingerprintUUIDProxyPatch(mode, fingerprintUUID, updateFingerprintProxyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes all session data associated with the fingerprint while preserving its configuration. This allows you to start fresh with the same fingerprint settings.
         * @summary ResetFingerprint
         * @param {string} mode 
         * @param {string} fingerprintUUID 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1FingerprintsFingerprintUUIDResetPost(mode: string, fingerprintUUID: string, body?: object, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.modeV1FingerprintsFingerprintUUIDResetPost(mode, fingerprintUUID, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ListFingerprints
         * @param {string} mode 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1FingerprintsGet(mode: string, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<ModeV1FingerprintsGet200Response> {
            return localVarFp.modeV1FingerprintsGet(mode, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new fingerprint with specified browser configuration, device settings, and proxy settings. This fingerprint can be used to start new browser sessions.
         * @summary CreateFingerprint
         * @param {string} mode 
         * @param {CreateFingerprintRequestBody} createFingerprintRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1FingerprintsPost(mode: string, createFingerprintRequestBody: CreateFingerprintRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<FingerprintWithSecret> {
            return localVarFp.modeV1FingerprintsPost(mode, createFingerprintRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Generates a new fingerprint with randomized browser configuration, device settings, and proxy settings.
         * @summary CreateRandomFingerprint
         * @param {string} mode 
         * @param {CreateRandomFingerprintRequest} createRandomFingerprintRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1FingerprintsRandomPost(mode: string, createRandomFingerprintRequest: CreateRandomFingerprintRequest, options?: RawAxiosRequestConfig): AxiosPromise<FingerprintWithSecret> {
            return localVarFp.modeV1FingerprintsRandomPost(mode, createRandomFingerprintRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FingerprintsApi - object-oriented interface
 * @export
 * @class FingerprintsApi
 * @extends {BaseAPI}
 */
export class FingerprintsApi extends BaseAPI {
    /**
     * Archives a fingerprint by deleting all associated session data and marking it as no longer usable. Once archived, the fingerprint cannot be used to create new sessions.
     * @summary ArchiveFingerprint
     * @param {string} mode 
     * @param {string} fingerprintUUID 
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FingerprintsApi
     */
    public modeV1FingerprintsFingerprintUUIDArchivePost(mode: string, fingerprintUUID: string, body?: object, options?: RawAxiosRequestConfig) {
        return FingerprintsApiFp(this.configuration).modeV1FingerprintsFingerprintUUIDArchivePost(mode, fingerprintUUID, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a copy of an existing fingerprint\'s settings but generates new session data. This allows you to duplicate a successful configuration while maintaining unique session identifiers.
     * @summary CloneFingerprint
     * @param {string} mode 
     * @param {string} fingerprintUUID 
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FingerprintsApi
     */
    public modeV1FingerprintsFingerprintUUIDClonePost(mode: string, fingerprintUUID: string, body?: object, options?: RawAxiosRequestConfig) {
        return FingerprintsApiFp(this.configuration).modeV1FingerprintsFingerprintUUIDClonePost(mode, fingerprintUUID, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves detailed information about a specific fingerprint, including its configuration, proxy settings, and session status.
     * @summary GetFingerprint
     * @param {string} mode 
     * @param {string} fingerprintUUID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FingerprintsApi
     */
    public modeV1FingerprintsFingerprintUUIDGet(mode: string, fingerprintUUID: string, options?: RawAxiosRequestConfig) {
        return FingerprintsApiFp(this.configuration).modeV1FingerprintsFingerprintUUIDGet(mode, fingerprintUUID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the proxy settings for a specific fingerprint. This allows you to change the geographic location and routing of browser traffic.
     * @summary UpdateFingerprintProxy
     * @param {string} mode 
     * @param {string} fingerprintUUID 
     * @param {UpdateFingerprintProxyRequest} updateFingerprintProxyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FingerprintsApi
     */
    public modeV1FingerprintsFingerprintUUIDProxyPatch(mode: string, fingerprintUUID: string, updateFingerprintProxyRequest: UpdateFingerprintProxyRequest, options?: RawAxiosRequestConfig) {
        return FingerprintsApiFp(this.configuration).modeV1FingerprintsFingerprintUUIDProxyPatch(mode, fingerprintUUID, updateFingerprintProxyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes all session data associated with the fingerprint while preserving its configuration. This allows you to start fresh with the same fingerprint settings.
     * @summary ResetFingerprint
     * @param {string} mode 
     * @param {string} fingerprintUUID 
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FingerprintsApi
     */
    public modeV1FingerprintsFingerprintUUIDResetPost(mode: string, fingerprintUUID: string, body?: object, options?: RawAxiosRequestConfig) {
        return FingerprintsApiFp(this.configuration).modeV1FingerprintsFingerprintUUIDResetPost(mode, fingerprintUUID, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ListFingerprints
     * @param {string} mode 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FingerprintsApi
     */
    public modeV1FingerprintsGet(mode: string, limit?: number, options?: RawAxiosRequestConfig) {
        return FingerprintsApiFp(this.configuration).modeV1FingerprintsGet(mode, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new fingerprint with specified browser configuration, device settings, and proxy settings. This fingerprint can be used to start new browser sessions.
     * @summary CreateFingerprint
     * @param {string} mode 
     * @param {CreateFingerprintRequestBody} createFingerprintRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FingerprintsApi
     */
    public modeV1FingerprintsPost(mode: string, createFingerprintRequestBody: CreateFingerprintRequestBody, options?: RawAxiosRequestConfig) {
        return FingerprintsApiFp(this.configuration).modeV1FingerprintsPost(mode, createFingerprintRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generates a new fingerprint with randomized browser configuration, device settings, and proxy settings.
     * @summary CreateRandomFingerprint
     * @param {string} mode 
     * @param {CreateRandomFingerprintRequest} createRandomFingerprintRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FingerprintsApi
     */
    public modeV1FingerprintsRandomPost(mode: string, createRandomFingerprintRequest: CreateRandomFingerprintRequest, options?: RawAxiosRequestConfig) {
        return FingerprintsApiFp(this.configuration).modeV1FingerprintsRandomPost(mode, createRandomFingerprintRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OperatorsApi - axios parameter creator
 * @export
 */
export const OperatorsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves information about all operators and total browser count
         * @summary Get operators information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OperatorsInfoGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/operators/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of all available operators
         * @summary List all operators
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OperatorsListAllGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/operators/listAll`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves detailed information about a specific operator
         * @summary Get operator information
         * @param {string} operatorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OperatorsOperatorIdInfoGet: async (operatorId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'operatorId' is not null or undefined
            assertParamExists('v1OperatorsOperatorIdInfoGet', 'operatorId', operatorId)
            const localVarPath = `/v1/operators/{operatorId}/info`
                .replace(`{${"operatorId"}}`, encodeURIComponent(String(operatorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a random operator ID
         * @summary Get random operator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OperatorsRandomGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/operators/random`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OperatorsApi - functional programming interface
 * @export
 */
export const OperatorsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OperatorsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves information about all operators and total browser count
         * @summary Get operators information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OperatorsInfoGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1OperatorsInfoGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OperatorsInfoGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperatorsApi.v1OperatorsInfoGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of all available operators
         * @summary List all operators
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OperatorsListAllGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1OperatorsListAllGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OperatorsListAllGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperatorsApi.v1OperatorsListAllGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves detailed information about a specific operator
         * @summary Get operator information
         * @param {string} operatorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OperatorsOperatorIdInfoGet(operatorId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Operator>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OperatorsOperatorIdInfoGet(operatorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperatorsApi.v1OperatorsOperatorIdInfoGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a random operator ID
         * @summary Get random operator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OperatorsRandomGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1OperatorsRandomGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OperatorsRandomGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OperatorsApi.v1OperatorsRandomGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OperatorsApi - factory interface
 * @export
 */
export const OperatorsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OperatorsApiFp(configuration)
    return {
        /**
         * Retrieves information about all operators and total browser count
         * @summary Get operators information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OperatorsInfoGet(options?: RawAxiosRequestConfig): AxiosPromise<V1OperatorsInfoGet200Response> {
            return localVarFp.v1OperatorsInfoGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of all available operators
         * @summary List all operators
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OperatorsListAllGet(options?: RawAxiosRequestConfig): AxiosPromise<V1OperatorsListAllGet200Response> {
            return localVarFp.v1OperatorsListAllGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves detailed information about a specific operator
         * @summary Get operator information
         * @param {string} operatorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OperatorsOperatorIdInfoGet(operatorId: string, options?: RawAxiosRequestConfig): AxiosPromise<Operator> {
            return localVarFp.v1OperatorsOperatorIdInfoGet(operatorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a random operator ID
         * @summary Get random operator
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OperatorsRandomGet(options?: RawAxiosRequestConfig): AxiosPromise<V1OperatorsRandomGet200Response> {
            return localVarFp.v1OperatorsRandomGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OperatorsApi - object-oriented interface
 * @export
 * @class OperatorsApi
 * @extends {BaseAPI}
 */
export class OperatorsApi extends BaseAPI {
    /**
     * Retrieves information about all operators and total browser count
     * @summary Get operators information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorsApi
     */
    public v1OperatorsInfoGet(options?: RawAxiosRequestConfig) {
        return OperatorsApiFp(this.configuration).v1OperatorsInfoGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of all available operators
     * @summary List all operators
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorsApi
     */
    public v1OperatorsListAllGet(options?: RawAxiosRequestConfig) {
        return OperatorsApiFp(this.configuration).v1OperatorsListAllGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves detailed information about a specific operator
     * @summary Get operator information
     * @param {string} operatorId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorsApi
     */
    public v1OperatorsOperatorIdInfoGet(operatorId: string, options?: RawAxiosRequestConfig) {
        return OperatorsApiFp(this.configuration).v1OperatorsOperatorIdInfoGet(operatorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a random operator ID
     * @summary Get random operator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperatorsApi
     */
    public v1OperatorsRandomGet(options?: RawAxiosRequestConfig) {
        return OperatorsApiFp(this.configuration).v1OperatorsRandomGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PageApi - axios parameter creator
 * @export
 */
export const PageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary executeCommands
         * @param {string} mode 
         * @param {ModeV1PageExecuteCommandsPostRequest} modeV1PageExecuteCommandsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1PageExecuteCommandsPost: async (mode: string, modeV1PageExecuteCommandsPostRequest: ModeV1PageExecuteCommandsPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mode' is not null or undefined
            assertParamExists('modeV1PageExecuteCommandsPost', 'mode', mode)
            // verify required parameter 'modeV1PageExecuteCommandsPostRequest' is not null or undefined
            assertParamExists('modeV1PageExecuteCommandsPost', 'modeV1PageExecuteCommandsPostRequest', modeV1PageExecuteCommandsPostRequest)
            const localVarPath = `/{mode}/v1/page/executeCommands`
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(modeV1PageExecuteCommandsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary goToPage
         * @param {string} mode 
         * @param {ModeV1PageGoToPagePostRequest} modeV1PageGoToPagePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1PageGoToPagePost: async (mode: string, modeV1PageGoToPagePostRequest: ModeV1PageGoToPagePostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mode' is not null or undefined
            assertParamExists('modeV1PageGoToPagePost', 'mode', mode)
            // verify required parameter 'modeV1PageGoToPagePostRequest' is not null or undefined
            assertParamExists('modeV1PageGoToPagePost', 'modeV1PageGoToPagePostRequest', modeV1PageGoToPagePostRequest)
            const localVarPath = `/{mode}/v1/page/goToPage`
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(modeV1PageGoToPagePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PageApi - functional programming interface
 * @export
 */
export const PageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PageApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary executeCommands
         * @param {string} mode 
         * @param {ModeV1PageExecuteCommandsPostRequest} modeV1PageExecuteCommandsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modeV1PageExecuteCommandsPost(mode: string, modeV1PageExecuteCommandsPostRequest: ModeV1PageExecuteCommandsPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modeV1PageExecuteCommandsPost(mode, modeV1PageExecuteCommandsPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PageApi.modeV1PageExecuteCommandsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary goToPage
         * @param {string} mode 
         * @param {ModeV1PageGoToPagePostRequest} modeV1PageGoToPagePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modeV1PageGoToPagePost(mode: string, modeV1PageGoToPagePostRequest: ModeV1PageGoToPagePostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modeV1PageGoToPagePost(mode, modeV1PageGoToPagePostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PageApi.modeV1PageGoToPagePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PageApi - factory interface
 * @export
 */
export const PageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PageApiFp(configuration)
    return {
        /**
         * 
         * @summary executeCommands
         * @param {string} mode 
         * @param {ModeV1PageExecuteCommandsPostRequest} modeV1PageExecuteCommandsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1PageExecuteCommandsPost(mode: string, modeV1PageExecuteCommandsPostRequest: ModeV1PageExecuteCommandsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.modeV1PageExecuteCommandsPost(mode, modeV1PageExecuteCommandsPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary goToPage
         * @param {string} mode 
         * @param {ModeV1PageGoToPagePostRequest} modeV1PageGoToPagePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1PageGoToPagePost(mode: string, modeV1PageGoToPagePostRequest: ModeV1PageGoToPagePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.modeV1PageGoToPagePost(mode, modeV1PageGoToPagePostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PageApi - object-oriented interface
 * @export
 * @class PageApi
 * @extends {BaseAPI}
 */
export class PageApi extends BaseAPI {
    /**
     * 
     * @summary executeCommands
     * @param {string} mode 
     * @param {ModeV1PageExecuteCommandsPostRequest} modeV1PageExecuteCommandsPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public modeV1PageExecuteCommandsPost(mode: string, modeV1PageExecuteCommandsPostRequest: ModeV1PageExecuteCommandsPostRequest, options?: RawAxiosRequestConfig) {
        return PageApiFp(this.configuration).modeV1PageExecuteCommandsPost(mode, modeV1PageExecuteCommandsPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary goToPage
     * @param {string} mode 
     * @param {ModeV1PageGoToPagePostRequest} modeV1PageGoToPagePostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageApi
     */
    public modeV1PageGoToPagePost(mode: string, modeV1PageGoToPagePostRequest: ModeV1PageGoToPagePostRequest, options?: RawAxiosRequestConfig) {
        return PageApiFp(this.configuration).modeV1PageGoToPagePost(mode, modeV1PageGoToPagePostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SessionsApi - axios parameter creator
 * @export
 */
export const SessionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves a list of all active browser sessions in your environment, including their status, VNC settings, and lease times.
         * @summary ListSessions
         * @param {string} mode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1SessionsGet: async (mode: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mode' is not null or undefined
            assertParamExists('modeV1SessionsGet', 'mode', mode)
            const localVarPath = `/{mode}/v1/sessions`
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new browser session using a specified fingerprint (OPTIONAL). Configure VNC access, lease time, and other session parameters.
         * @summary CreateSessionWithoutFingerprint
         * @param {string} mode 
         * @param {CreateSessionRequestBody} createSessionRequestBody 
         * @param {string} [xFingerprintSecret] 
         * @param {string} [xEnvironmentId] 
         * @param {string} [xEnvironmentSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1SessionsPost: async (mode: string, createSessionRequestBody: CreateSessionRequestBody, xFingerprintSecret?: string, xEnvironmentId?: string, xEnvironmentSecret?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mode' is not null or undefined
            assertParamExists('modeV1SessionsPost', 'mode', mode)
            // verify required parameter 'createSessionRequestBody' is not null or undefined
            assertParamExists('modeV1SessionsPost', 'createSessionRequestBody', createSessionRequestBody)
            const localVarPath = `/{mode}/v1/sessions`
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xFingerprintSecret != null) {
                localVarHeaderParameter['X-Fingerprint-Secret'] = String(xFingerprintSecret);
            }
            if (xEnvironmentId != null) {
                localVarHeaderParameter['X-Environment-Id'] = String(xEnvironmentId);
            }
            if (xEnvironmentSecret != null) {
                localVarHeaderParameter['X-Environment-Secret'] = String(xEnvironmentSecret);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createSessionRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Terminates a browser session immediately, releasing all associated resources and ending the lease.
         * @summary EndSession
         * @param {string} mode 
         * @param {string} sessionUUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1SessionsSessionUUIDDelete: async (mode: string, sessionUUID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mode' is not null or undefined
            assertParamExists('modeV1SessionsSessionUUIDDelete', 'mode', mode)
            // verify required parameter 'sessionUUID' is not null or undefined
            assertParamExists('modeV1SessionsSessionUUIDDelete', 'sessionUUID', sessionUUID)
            const localVarPath = `/{mode}/v1/sessions/{sessionUUID}`
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)))
                .replace(`{${"sessionUUID"}}`, encodeURIComponent(String(sessionUUID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves detailed information about a specific browser session, including its status, settings, and remaining lease time.
         * @summary GetSession
         * @param {string} mode 
         * @param {string} sessionUUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1SessionsSessionUUIDGet: async (mode: string, sessionUUID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mode' is not null or undefined
            assertParamExists('modeV1SessionsSessionUUIDGet', 'mode', mode)
            // verify required parameter 'sessionUUID' is not null or undefined
            assertParamExists('modeV1SessionsSessionUUIDGet', 'sessionUUID', sessionUUID)
            const localVarPath = `/{mode}/v1/sessions/{sessionUUID}`
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)))
                .replace(`{${"sessionUUID"}}`, encodeURIComponent(String(sessionUUID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the settings of an active browser session. Currently supports extending the lease time.
         * @summary UpdateSession
         * @param {string} mode 
         * @param {string} sessionUUID 
         * @param {UpdateSessionRequestBody} updateSessionRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1SessionsSessionUUIDPatch: async (mode: string, sessionUUID: string, updateSessionRequestBody: UpdateSessionRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mode' is not null or undefined
            assertParamExists('modeV1SessionsSessionUUIDPatch', 'mode', mode)
            // verify required parameter 'sessionUUID' is not null or undefined
            assertParamExists('modeV1SessionsSessionUUIDPatch', 'sessionUUID', sessionUUID)
            // verify required parameter 'updateSessionRequestBody' is not null or undefined
            assertParamExists('modeV1SessionsSessionUUIDPatch', 'updateSessionRequestBody', updateSessionRequestBody)
            const localVarPath = `/{mode}/v1/sessions/{sessionUUID}`
                .replace(`{${"mode"}}`, encodeURIComponent(String(mode)))
                .replace(`{${"sessionUUID"}}`, encodeURIComponent(String(sessionUUID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApiKeyUUID required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSessionRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SessionsApi - functional programming interface
 * @export
 */
export const SessionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SessionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves a list of all active browser sessions in your environment, including their status, VNC settings, and lease times.
         * @summary ListSessions
         * @param {string} mode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modeV1SessionsGet(mode: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModeV1SessionsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modeV1SessionsGet(mode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionsApi.modeV1SessionsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new browser session using a specified fingerprint (OPTIONAL). Configure VNC access, lease time, and other session parameters.
         * @summary CreateSessionWithoutFingerprint
         * @param {string} mode 
         * @param {CreateSessionRequestBody} createSessionRequestBody 
         * @param {string} [xFingerprintSecret] 
         * @param {string} [xEnvironmentId] 
         * @param {string} [xEnvironmentSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modeV1SessionsPost(mode: string, createSessionRequestBody: CreateSessionRequestBody, xFingerprintSecret?: string, xEnvironmentId?: string, xEnvironmentSecret?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Session>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modeV1SessionsPost(mode, createSessionRequestBody, xFingerprintSecret, xEnvironmentId, xEnvironmentSecret, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionsApi.modeV1SessionsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Terminates a browser session immediately, releasing all associated resources and ending the lease.
         * @summary EndSession
         * @param {string} mode 
         * @param {string} sessionUUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modeV1SessionsSessionUUIDDelete(mode: string, sessionUUID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modeV1SessionsSessionUUIDDelete(mode, sessionUUID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionsApi.modeV1SessionsSessionUUIDDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves detailed information about a specific browser session, including its status, settings, and remaining lease time.
         * @summary GetSession
         * @param {string} mode 
         * @param {string} sessionUUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modeV1SessionsSessionUUIDGet(mode: string, sessionUUID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Session>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modeV1SessionsSessionUUIDGet(mode, sessionUUID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionsApi.modeV1SessionsSessionUUIDGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the settings of an active browser session. Currently supports extending the lease time.
         * @summary UpdateSession
         * @param {string} mode 
         * @param {string} sessionUUID 
         * @param {UpdateSessionRequestBody} updateSessionRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modeV1SessionsSessionUUIDPatch(mode: string, sessionUUID: string, updateSessionRequestBody: UpdateSessionRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modeV1SessionsSessionUUIDPatch(mode, sessionUUID, updateSessionRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionsApi.modeV1SessionsSessionUUIDPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SessionsApi - factory interface
 * @export
 */
export const SessionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SessionsApiFp(configuration)
    return {
        /**
         * Retrieves a list of all active browser sessions in your environment, including their status, VNC settings, and lease times.
         * @summary ListSessions
         * @param {string} mode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1SessionsGet(mode: string, options?: RawAxiosRequestConfig): AxiosPromise<ModeV1SessionsGet200Response> {
            return localVarFp.modeV1SessionsGet(mode, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new browser session using a specified fingerprint (OPTIONAL). Configure VNC access, lease time, and other session parameters.
         * @summary CreateSessionWithoutFingerprint
         * @param {string} mode 
         * @param {CreateSessionRequestBody} createSessionRequestBody 
         * @param {string} [xFingerprintSecret] 
         * @param {string} [xEnvironmentId] 
         * @param {string} [xEnvironmentSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1SessionsPost(mode: string, createSessionRequestBody: CreateSessionRequestBody, xFingerprintSecret?: string, xEnvironmentId?: string, xEnvironmentSecret?: string, options?: RawAxiosRequestConfig): AxiosPromise<Session> {
            return localVarFp.modeV1SessionsPost(mode, createSessionRequestBody, xFingerprintSecret, xEnvironmentId, xEnvironmentSecret, options).then((request) => request(axios, basePath));
        },
        /**
         * Terminates a browser session immediately, releasing all associated resources and ending the lease.
         * @summary EndSession
         * @param {string} mode 
         * @param {string} sessionUUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1SessionsSessionUUIDDelete(mode: string, sessionUUID: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.modeV1SessionsSessionUUIDDelete(mode, sessionUUID, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves detailed information about a specific browser session, including its status, settings, and remaining lease time.
         * @summary GetSession
         * @param {string} mode 
         * @param {string} sessionUUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1SessionsSessionUUIDGet(mode: string, sessionUUID: string, options?: RawAxiosRequestConfig): AxiosPromise<Session> {
            return localVarFp.modeV1SessionsSessionUUIDGet(mode, sessionUUID, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the settings of an active browser session. Currently supports extending the lease time.
         * @summary UpdateSession
         * @param {string} mode 
         * @param {string} sessionUUID 
         * @param {UpdateSessionRequestBody} updateSessionRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modeV1SessionsSessionUUIDPatch(mode: string, sessionUUID: string, updateSessionRequestBody: UpdateSessionRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.modeV1SessionsSessionUUIDPatch(mode, sessionUUID, updateSessionRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SessionsApi - object-oriented interface
 * @export
 * @class SessionsApi
 * @extends {BaseAPI}
 */
export class SessionsApi extends BaseAPI {
    /**
     * Retrieves a list of all active browser sessions in your environment, including their status, VNC settings, and lease times.
     * @summary ListSessions
     * @param {string} mode 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public modeV1SessionsGet(mode: string, options?: RawAxiosRequestConfig) {
        return SessionsApiFp(this.configuration).modeV1SessionsGet(mode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new browser session using a specified fingerprint (OPTIONAL). Configure VNC access, lease time, and other session parameters.
     * @summary CreateSessionWithoutFingerprint
     * @param {string} mode 
     * @param {CreateSessionRequestBody} createSessionRequestBody 
     * @param {string} [xFingerprintSecret] 
     * @param {string} [xEnvironmentId] 
     * @param {string} [xEnvironmentSecret] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public modeV1SessionsPost(mode: string, createSessionRequestBody: CreateSessionRequestBody, xFingerprintSecret?: string, xEnvironmentId?: string, xEnvironmentSecret?: string, options?: RawAxiosRequestConfig) {
        return SessionsApiFp(this.configuration).modeV1SessionsPost(mode, createSessionRequestBody, xFingerprintSecret, xEnvironmentId, xEnvironmentSecret, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Terminates a browser session immediately, releasing all associated resources and ending the lease.
     * @summary EndSession
     * @param {string} mode 
     * @param {string} sessionUUID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public modeV1SessionsSessionUUIDDelete(mode: string, sessionUUID: string, options?: RawAxiosRequestConfig) {
        return SessionsApiFp(this.configuration).modeV1SessionsSessionUUIDDelete(mode, sessionUUID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves detailed information about a specific browser session, including its status, settings, and remaining lease time.
     * @summary GetSession
     * @param {string} mode 
     * @param {string} sessionUUID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public modeV1SessionsSessionUUIDGet(mode: string, sessionUUID: string, options?: RawAxiosRequestConfig) {
        return SessionsApiFp(this.configuration).modeV1SessionsSessionUUIDGet(mode, sessionUUID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the settings of an active browser session. Currently supports extending the lease time.
     * @summary UpdateSession
     * @param {string} mode 
     * @param {string} sessionUUID 
     * @param {UpdateSessionRequestBody} updateSessionRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public modeV1SessionsSessionUUIDPatch(mode: string, sessionUUID: string, updateSessionRequestBody: UpdateSessionRequestBody, options?: RawAxiosRequestConfig) {
        return SessionsApiFp(this.configuration).modeV1SessionsSessionUUIDPatch(mode, sessionUUID, updateSessionRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



